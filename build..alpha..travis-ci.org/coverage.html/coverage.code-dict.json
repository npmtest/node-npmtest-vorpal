{"/home/travis/build/npmtest/node-npmtest-vorpal/test.js":"/* istanbul instrument in package npmtest_vorpal */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-vorpal/lib.npmtest_vorpal.js":"/* istanbul instrument in package npmtest_vorpal */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_vorpal = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_vorpal = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-vorpal/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-vorpal && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_vorpal */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_vorpal\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_vorpal.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_vorpal.rollup.js'] =\n            local.assetsDict['/assets.npmtest_vorpal.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_vorpal.__dirname + '/lib.npmtest_vorpal.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/vorpal.js":"'use strict';\n\n/**\n * Polyfill for ES6.\n */\n\nif (!global._babelPolyfill) {\n  // When the runtime transformer properly detects all shimmed methods, use instead.\n  // http://www.2ality.com/2015/12/babel6-helpersstandard-library.html#babel-plugin-transform-runtime\n  require('babel-polyfill');\n}\n\n/**\n * Module dependencies.\n */\n\nvar _ = require('lodash');\nvar EventEmitter = require('events').EventEmitter;\nvar Command = require('./command');\nvar CommandInstance = require('./command-instance');\nvar VorpalUtil = require('./util');\nvar ui = require('./ui');\nvar Session = require('./session');\nvar intercept = require('./intercept');\nvar minimist = require('minimist');\nvar commons = require('./vorpal-commons');\nvar chalk = require('chalk');\nvar os = require('os');\nvar History = require('./history');\nvar LocalStorage = require('./local-storage');\nvar wrap = require('wrap-ansi');\n\n/**\n * Initialize a new `Vorpal` instance.\n *\n * @return {Vorpal}\n * @api public\n */\n\nfunction Vorpal() {\n  if (!(this instanceof Vorpal)) {\n    return new Vorpal();\n  }\n\n  // Program version\n  // Exposed through vorpal.version(str);\n  this._version = '';\n\n  // Command line history instance\n  this.cmdHistory = new this.CmdHistoryExtension();\n\n  // Registered `vorpal.command` commands and\n  // their options.\n  this.commands = [];\n\n  // Queue of IP requests, executed async, in sync.\n  this._queue = [];\n\n  // Current command being executed.\n  this._command = undefined;\n\n  // Expose UI.\n  this.ui = ui;\n\n  // Expose chalk as a convenience.\n  this.chalk = chalk;\n\n  // Expose lodash as a convenience.\n  this.lodash = _;\n\n  // Exposed through vorpal.delimiter(str).\n  this._delimiter = 'local@' + String(os.hostname()).split('.')[0] + '~$ ';\n  ui.setDelimiter(this._delimiter);\n\n  // Placeholder for vantage server. If vantage\n  // is used, this will be over-written.\n  this.server = {\n    sessions: []\n  };\n\n  // Whether all stdout is being hooked through a function.\n  this._hooked = false;\n\n  this._useDeprecatedAutocompletion = false;\n\n  // Expose common utilities, like padding.\n  this.util = VorpalUtil;\n\n  this.Session = Session;\n\n  // Active vorpal server session.\n  this.session = new this.Session({\n    local: true,\n    user: 'local',\n    parent: this,\n    delimiter: this._delimiter\n  });\n\n  // Allow unix-like key value pair normalization to be turned off by toggling this switch on.\n  this.isCommandArgKeyPairNormalized = true;\n\n  this._init();\n  return this;\n}\n\n/**\n * Extend Vorpal prototype as an event emitter.\n */\n\nVorpal.prototype = Object.create(EventEmitter.prototype);\n\n/**\n * Vorpal prototype.\n */\n\nvar vorpal = Vorpal.prototype;\n\n/**\n * Expose `Vorpal`.\n */\n\nexports = module.exports = Vorpal;\n\n/**\n * Extension to `constructor`.\n * @api private\n */\n\nVorpal.prototype._init = function () {\n  var self = this;\n\n  ui.on('vorpal_ui_keypress', function (data) {\n    self.emit('keypress', data);\n    self._onKeypress(data.key, data.value);\n  });\n\n  self.use(commons);\n};\n\n/**\n * Parses `process.argv` and executes\n * a Vorpal command based on it.\n * @api public\n */\n\nVorpal.prototype.parse = function (argv, options) {\n  options = options || {};\n  var args = argv;\n  var result = this;\n  var catchExists = !(_.find(this.commands, { _catch: true }) === undefined);\n  args.shift();\n  args.shift();\n  if (args.length > 0 || catchExists) {\n    if (options.use === 'minimist') {\n      result = minimist(args);\n    } else {\n      // Wrap the spaced args back in quotes.\n      for (var i = 0; i < args.length; ++i) {\n        if (i === 0) {\n          continue;\n        }\n        if (args[i].indexOf(' ') > -1) {\n          args[i] = '\"' + args[i] + '\"';\n        }\n      }\n      this.exec(args.join(' '), function (err) {\n        if (err !== undefined && err !== null) {\n          throw new Error(err);\n        }\n        process.exit(0);\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Sets version of your application's API.\n *\n * @param {String} version\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.version = function (version) {\n  this._version = version;\n  return this;\n};\n\n/**\n * Sets the permanent delimiter for this\n * Vorpal server instance.\n *\n * @param {String} str\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.delimiter = function (str) {\n  this._delimiter = str;\n  if (this.session.isLocal() && !this.session.client) {\n    this.session.delimiter(str);\n  }\n  return this;\n};\n\n/**\n * Imports a library of Vorpal API commands\n * from another Node module as an extension\n * of Vorpal.\n *\n * @param {Array} commands\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.use = function (commands, options) {\n  if (!commands) {\n    return this;\n  }\n  if (_.isFunction(commands)) {\n    commands.call(this, this, options);\n  } else if (_.isString(commands)) {\n    return this.use(require(commands), options);\n  } else {\n    commands = _.isArray(commands) ? commands : [commands];\n    for (var i = 0; i < commands.length; ++i) {\n      var cmd = commands[i];\n      if (cmd.command) {\n        var command = this.command(cmd.command);\n        if (cmd.description) {\n          command.description(cmd.description);\n        }\n        if (cmd.options) {\n          cmd.options = _.isArray(cmd.options) ? cmd.options : [cmd.options];\n          for (var j = 0; j < cmd.options.length; ++j) {\n            command.option(cmd.options[j][0], cmd.options[j][1]);\n          }\n        }\n        if (cmd.action) {\n          command.action(cmd.action);\n        }\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * Registers a new command in the vorpal API.\n *\n * @param {String} name\n * @param {String} desc\n * @param {Object} opts\n * @return {Command}\n * @api public\n */\n\nvorpal.command = function (name, desc, opts) {\n  opts = opts || {};\n  name = String(name);\n\n  var argsRegExp = /(\\[[^\\]]*\\]|\\<[^\\>]*\\>)/g;\n  var args = [];\n  var arg;\n\n  while ((arg = argsRegExp.exec(name)) !== null) {\n    args.push(arg[1]);\n  }\n\n  var cmdNameRegExp = /^([^\\[\\<]*)/;\n  var cmdName = cmdNameRegExp.exec(name)[0].trim();\n\n  var cmd = new Command(cmdName, this);\n\n  if (desc) {\n    cmd.description(desc);\n    this.executables = true;\n  }\n\n  cmd._noHelp = Boolean(opts.noHelp);\n  cmd._mode = opts.mode || false;\n  cmd._catch = opts.catch || false;\n  cmd._parseExpectedArgs(args);\n  cmd.parent = this;\n\n  var exists = false;\n  for (var i = 0; i < this.commands.length; ++i) {\n    exists = this.commands[i]._name === cmd._name ? true : exists;\n    if (exists) {\n      this.commands[i] = cmd;\n      break;\n    }\n  }\n  if (!exists) {\n    this.commands.push(cmd);\n  } else {\n    console.warn(chalk.yellow('Warning: command named \"' + name + '\" was registered more than once.\\nIf you intend to override a command, you should explicitly remove the first command with command.remove().'));\n  }\n\n  this.emit('command_registered', { command: cmd, name: name });\n\n  return cmd;\n};\n\n/**\n * Registers a new 'mode' command in the vorpal API.\n *\n * @param {String} name\n * @param {String} desc\n * @param {Object} opts\n * @return {Command}\n * @api public\n */\n\nvorpal.mode = function (name, desc, opts) {\n  return this.command(name, desc, _.extend(opts || {}, { mode: true }));\n};\n\n/**\n * Registers a 'catch' command in the vorpal API.\n * This is executed when no command matches are found.\n *\n * @param {String} name\n * @param {String} desc\n * @param {Object} opts\n * @return {Command}\n * @api public\n */\n\nvorpal.catch = function (name, desc, opts) {\n  return this.command(name, desc, _.extend(opts || {}, { catch: true }));\n};\n\n/**\n * An alias to the `catch` command.\n *\n * @param {String} name\n * @param {String} desc\n * @param {Object} opts\n * @return {Command}\n * @api public\n */\n\nvorpal.default = function (name, desc, opts) {\n  return this.command(name, desc, _.extend(opts || {}, { catch: true }));\n};\n\n/**\n * Delegates to ui.log.\n *\n * @param {String} log\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.log = function () {\n  this.ui.log.apply(this.ui, arguments);\n  return this;\n};\n\n/**\n * Intercepts all logging through `vorpal.log`\n * and runs it through the function declared by\n * `vorpal.pipe()`.\n *\n * @param {Function} fn\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.pipe = function (fn) {\n  if (this.ui) {\n    this.ui._pipeFn = fn;\n  }\n  return this;\n};\n\n/**\n * If Vorpal is the local terminal,\n * hook all stdout, through a fn.\n *\n * @return {Vorpal}\n * @api private\n */\n\nvorpal.hook = function (fn) {\n  if (fn !== undefined) {\n    this._hook(fn);\n  } else {\n    this._unhook();\n  }\n  return this;\n};\n\n/**\n * Unhooks stdout capture.\n *\n * @return {Vorpal}\n * @api public\n */\n\nvorpal._unhook = function () {\n  if (this._hooked && this._unhook !== undefined) {\n    this._unhook();\n    this._hooked = false;\n  }\n  return this;\n};\n\n/**\n * Hooks all stdout through a given function.\n *\n * @param {Function} fn\n * @return {Vorpal}\n * @api public\n */\n\nvorpal._hook = function (fn) {\n  if (this._hooked && this._unhook !== undefined) {\n    this._unhook();\n  }\n  this._unhook = intercept(fn);\n  this._hooked = true;\n  return this;\n};\n\n/**\n * History module used to get command history\n */\nvorpal.CmdHistoryExtension = History;\n\n/**\n * Set id for command line history\n * @param id\n * @return {Vorpal}\n * @api public\n */\nvorpal.history = function (id) {\n  this.cmdHistory.setId(id);\n  return this;\n};\n\n/**\n * Set id for local storage\n * @param id\n * @return {Vorpal}\n * @api public\n */\nvorpal.localStorage = function (id) {\n  var ls = Object.create(LocalStorage);\n  ls.setId(id);\n  _.extend(this.localStorage, ls);\n  return this;\n};\n\n/**\n * Set the path to where command line history is persisted.\n * Must be called before vorpal.history\n * @param path\n * @return {Vorpal}\n * @api public\n */\nvorpal.historyStoragePath = function (path) {\n  this.cmdHistory.setStoragePath(path);\n  return this;\n};\n\n/**\n * Hook the tty prompt to this given instance\n * of vorpal.\n *\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.show = function () {\n  ui.attach(this);\n  return this;\n};\n\n/**\n * Disables the vorpal prompt on the\n * local terminal.\n *\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.hide = function () {\n  ui.detach(this);\n  return this;\n};\n\n/**\n * Listener for a UI keypress. Either\n * handles the keypress locally or sends\n * it upstream.\n *\n * @param {String} key\n * @param {String} value\n * @api private\n */\n\nvorpal._onKeypress = function (key, value) {\n  var self = this;\n  if (this.session.isLocal() && !this.session.client && !this._command) {\n    this.session.getKeypressResult(key, value, function (err, result) {\n      if (!err && result !== undefined) {\n        if (_.isArray(result)) {\n          var formatted = VorpalUtil.prettifyArray(result);\n          self.ui.imprint();\n          self.session.log(formatted);\n        } else {\n          self.ui.input(result);\n        }\n      }\n    });\n  } else {\n    this._send('vantage-keypress-upstream', 'upstream', {\n      key: key,\n      value: value,\n      sessionId: this.session.id\n    });\n  }\n};\n\n/**\n * For use in vorpal API commands, sends\n * a prompt command downstream to the local\n * terminal. Executes a prompt and returns\n * the response upstream to the API command.\n *\n * @param {Object} options\n * @param {Function} userCallback\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.prompt = function () {\n  var _this = this;\n\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  var userCallback = arguments[1];\n\n  return new Promise(function (resolve) {\n    // Setup callback to also resolve promise.\n    var cb = function cb(response) {\n      // Does not currently handle Inquirer validation errors.\n      resolve(response);\n      if (userCallback) {\n        userCallback(response);\n      }\n    };\n\n    var prompt = undefined;\n    var ssn = _this.getSessionById(options.sessionId);\n\n    if (!ssn) {\n      throw new Error('Vorpal.prompt was called without a passed Session ID.');\n    }\n\n    var handler = function handler(data) {\n      var response = data.value;\n      _this.removeListener('vantage-prompt-upstream', handler);\n      cb(response);\n    };\n\n    if (ssn.isLocal()) {\n      ui.setDelimiter(options.message || ssn.delimiter());\n      prompt = ui.prompt(options, function (result) {\n        ui.setDelimiter(ssn.delimiter());\n        cb(result);\n      });\n    } else {\n      _this.on('vantage-prompt-upstream', handler);\n      _this._send('vantage-prompt-downstream', 'downstream', { options: options, value: undefined, sessionId: ssn.id });\n    }\n    return prompt;\n  });\n};\n\n/**\n * Renders the CLI prompt or sends the\n * request to do so downstream.\n *\n * @param {Object} data\n * @return {Vorpal}\n * @api private\n */\n\nvorpal._prompt = function (data) {\n  var self = this;\n  var prompt;\n  data = data || {};\n  if (!data.sessionId) {\n    data.sessionId = self.session.id;\n  }\n  var ssn = self.getSessionById(data.sessionId);\n\n  // If we somehow got to _prompt and aren't the\n  // local client, send the command downstream.\n  if (!ssn.isLocal()) {\n    this._send('vantage-resume-downstream', 'downstream', { sessionId: data.sessionId });\n    return self;\n  }\n\n  if (ui.midPrompt()) {\n    return self;\n  }\n\n  prompt = ui.prompt({\n    type: 'input',\n    name: 'command',\n    message: ssn.fullDelimiter()\n  }, function (result) {\n    if (self.ui._cancelled === true) {\n      self.ui._cancelled = false;return;\n    }\n    var str = String(result.command).trim();\n    self.emit('client_prompt_submit', str);\n    if (str === '' || str === 'undefined') {\n      self._prompt(data);return;\n    }\n    self.exec(str, function () {\n      self._prompt(data);\n    });\n  });\n\n  return prompt;\n};\n\n/**\n * Executes a vorpal API command and\n * returns the response either through a\n * callback or Promise in the absence\n * of a callback.\n *\n * A little black magic here - because\n * we sometimes have to send commands 10\n * miles upstream through 80 other instances\n * of vorpal and we aren't going to send\n * the callback / promise with us on that\n * trip, we store the command, callback,\n * resolve and reject objects (as they apply)\n * in a local vorpal._command variable.\n *\n * When the command eventually comes back\n * downstream, we dig up the callbacks and\n * finally resolve or reject the promise, etc.\n *\n * Lastly, to add some more complexity, we throw\n * command and callbacks into a queue that will\n * be unearthed and sent in due time.\n *\n * @param {String} cmd\n * @param {Function} cb\n * @return {Promise or Vorpal}\n * @api public\n */\n\nvorpal.exec = function (cmd, args, cb) {\n  var self = this;\n  var ssn = self.session;\n\n  cb = _.isFunction(args) ? args : cb;\n  args = args || {};\n\n  if (args.sessionId) {\n    ssn = self.getSessionById(args.sessionId);\n  }\n\n  var command = {\n    command: cmd,\n    args: args,\n    callback: cb,\n    session: ssn\n  };\n\n  if (cb !== undefined) {\n    self._queue.push(command);\n    self._queueHandler();\n    return self;\n  }\n\n  return new Promise(function (resolve, reject) {\n    command.resolve = resolve;\n    command.reject = reject;\n    self._queue.push(command);\n    self._queueHandler();\n  });\n};\n\n/**\n * Executes a Vorpal command in sync.\n *\n * @param {String} cmd\n * @param {Object} args\n * @return {*} stdout\n * @api public\n */\n\nvorpal.execSync = function (cmd, options) {\n  var self = this;\n  var ssn = self.session;\n  options = options || {};\n  if (options.sessionId) {\n    ssn = self.getSessionById(options.sessionId);\n  }\n\n  var command = {\n    command: cmd,\n    args: options,\n    session: ssn,\n    sync: true,\n    options: options\n  };\n\n  return self._execQueueItem(command);\n};\n\n/**\n * Commands issued to Vorpal server\n * are executed in sequence. Called once\n * when a command is inserted or completes,\n * shifts the next command in the queue\n * and sends it to `vorpal._execQueueItem`.\n *\n * @api private\n */\n\nvorpal._queueHandler = function () {\n  if (this._queue.length > 0 && this._command === undefined) {\n    var item = this._queue.shift();\n    this._execQueueItem(item);\n  }\n};\n\n/**\n * Fires off execution of a command - either\n * calling upstream or executing locally.\n *\n * @param {Object} cmd\n * @api private\n */\n\nvorpal._execQueueItem = function (cmd) {\n  var self = this;\n  self._command = cmd;\n  if (cmd.session.isLocal() && !cmd.session.client) {\n    return this._exec(cmd);\n  }\n  self._send('vantage-command-upstream', 'upstream', {\n    command: cmd.command,\n    args: cmd.args,\n    completed: false,\n    sessionId: cmd.session.id\n  });\n};\n\n/**\n * Executes a vorpal API command.\n * Warning: Dragons lie beyond this point.\n *\n * @param {String} item\n * @api private\n */\n\nvorpal._exec = function (item) {\n  var self = this;\n  item = item || {};\n  item.command = item.command || '';\n  var modeCommand = item.command;\n  item.command = item.session._mode ? item.session._mode : item.command;\n\n  var promptCancelled = false;\n  if (this.ui._midPrompt) {\n    promptCancelled = true;\n    this.ui.cancel();\n  }\n\n  if (!item.session) {\n    throw new Error('Fatal Error: No session was passed into command for execution: ' + item);\n  }\n\n  if (String(item.command).indexOf('undefine') > -1) {\n    throw new Error('vorpal._exec was called with an undefined command.');\n  }\n\n  // History for our 'up' and 'down' arrows.\n  item.session.history(item.session._mode ? modeCommand : item.command);\n\n  var commandData = this.util.parseCommand(item.command, this.commands);\n  item.command = commandData.command;\n  item.pipes = commandData.pipes;\n  var match = commandData.match;\n  var matchArgs = commandData.matchArgs;\n\n  function throwHelp(cmd, msg, alternativeMatch) {\n    if (msg) {\n      cmd.session.log(msg);\n    }\n    var pickedMatch = alternativeMatch || match;\n    cmd.session.log(pickedMatch.helpInformation());\n  }\n\n  function callback(cmd, err, msg, argus) {\n    // Resume the prompt if we had to cancel\n    // an active prompt, due to programmatic\n    // execution.\n    if (promptCancelled) {\n      self._prompt();\n    }\n    if (cmd.sync) {\n      // If we want the command to be fatal,\n      // throw a real error. Otherwise, silently\n      // return the error.\n      delete self._command;\n      if (err) {\n        if (cmd.options && (cmd.options.fatal === true || vorpal._fatal === true)) {\n          throw new Error(err);\n        }\n        return err;\n      }\n      return msg;\n    } else if (cmd.callback) {\n      if (argus) {\n        cmd.callback.apply(self, argus);\n      } else {\n        cmd.callback.call(self, err, msg);\n      }\n    } else if (!err && cmd.resolve) {\n      cmd.resolve(msg);\n    } else if (err && cmd.reject) {\n      cmd.reject(msg);\n    }\n    delete self._command;\n    self._queueHandler();\n  }\n\n  if (match) {\n    item.fn = match._fn;\n    item._cancel = match._cancel;\n    item.validate = match._validate;\n    item.commandObject = match;\n    var init = match._init || function (arrgs, cb) {\n      cb();\n    };\n    var delimiter = match._delimiter || String(item.command).toLowerCase() + ':';\n\n    item.args = self.util.buildCommandArgs(matchArgs, match, item, self.isCommandArgKeyPairNormalized);\n\n    // If we get a string back, it's a validation error.\n    // Show help and return.\n    if (_.isString(item.args) || !_.isObject(item.args)) {\n      throwHelp(item, item.args);\n      return callback(item, undefined, item.args);\n    }\n\n    // Build the piped commands.\n    var allValid = true;\n    for (var j = 0; j < item.pipes.length; ++j) {\n      var commandParts = self.util.matchCommand(item.pipes[j], self.commands);\n      if (!commandParts.command) {\n        item.session.log(self._commandHelp(item.pipes[j]));\n        allValid = false;\n        break;\n      }\n      commandParts.args = self.util.buildCommandArgs(commandParts.args, commandParts.command);\n      if (_.isString(commandParts.args) || !_.isObject(commandParts.args)) {\n        throwHelp(item, commandParts.args, commandParts.command);\n        allValid = false;\n        break;\n      }\n      item.pipes[j] = commandParts;\n    }\n    // If invalid piped commands, return.\n    if (!allValid) {\n      return callback(item);\n    }\n\n    // If `--help` or `/?` is passed, do help.\n    if (item.args.options.help && _.isFunction(match._help)) {\n      // If the command has a custom help function, run it\n      // as the actual \"command\". In this way it can go through\n      // the whole cycle and expect a callback.\n      item.fn = match._help;\n      delete item.validate;\n      delete item._cancel;\n    } else if (item.args.options.help) {\n      // Otherwise, throw the standard help.\n      throwHelp(item, '');\n      return callback(item);\n    }\n\n    // If this command throws us into a 'mode',\n    // prepare for it.\n    if (match._mode === true && !item.session._mode) {\n      // Assign vorpal to be in a 'mode'.\n      item.session._mode = item.command;\n      // Execute the mode's `init` function\n      // instead of the `action` function.\n      item.fn = init;\n      delete item.validate;\n\n      self.cmdHistory.enterMode();\n      item.session.modeDelimiter(delimiter);\n    } else if (item.session._mode) {\n      if (String(modeCommand).trim() === 'exit') {\n        self._exitMode({ sessionId: item.session.id });\n        return callback(item);\n      }\n      // This executes when actually in a 'mode'\n      // session. We now pass in the raw text of what\n      // is typed into the first param of `action`\n      // instead of arguments.\n      item.args = modeCommand;\n    }\n\n    if (item.sync === true) {\n      // If we're running synchronous commands,\n      // we don't support piping.\n      var response;\n      var error;\n      try {\n        response = item.fn.call(new CommandInstance({\n          downstream: undefined,\n          commandWrapper: item,\n          commandObject: item.commandObject,\n          args: item.args\n        }), item.args);\n      } catch (e) {\n        error = e;\n      }\n      return callback(item, error, response);\n    }\n\n    // Builds commandInstance objects for every\n    // command and piped command included in the\n    // execution string.\n\n    // Build the instances for each pipe.\n    item.pipes = item.pipes.map(function (pipe) {\n      return new CommandInstance({\n        commandWrapper: item,\n        command: pipe.command._name,\n        commandObject: pipe.command,\n        args: pipe.args\n      });\n    });\n\n    // Reverse through the pipes and assign the\n    // `downstream` object of each parent to its\n    // child command.\n    for (var k = item.pipes.length - 1; k > -1; --k) {\n      var downstream = item.pipes[k + 1];\n      item.pipes[k].downstream = downstream;\n    }\n\n    item.session.execCommandSet(item, function (wrapper, err, data, argus) {\n      callback(wrapper, err, data, argus);\n    });\n  } else {\n    // If no command match, just return.\n    item.session.log(this._commandHelp(item.command));\n    return callback(item, undefined, 'Invalid command.');\n  }\n};\n\n/**\n * Exits out of a give 'mode' one is in.\n * Reverts history and delimiter back to\n * regular vorpal usage.\n *\n * @api private\n */\n\nvorpal._exitMode = function (options) {\n  var ssn = this.getSessionById(options.sessionId);\n  ssn._mode = false;\n  this.cmdHistory.exitMode();\n  ssn.modeDelimiter(false);\n  this.emit('mode_exit', this.cmdHistory.peek());\n};\n\n/**\n * Registers a custom handler for SIGINT.\n * Vorpal exits with 0 by default\n * on a sigint.\n *\n * @param {Function} fn\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.sigint = function (fn) {\n  if (_.isFunction(fn)) {\n    ui.sigint(fn);\n  } else {\n    throw new Error('vorpal.sigint must be passed in a valid function.');\n  }\n  return this;\n};\n\n/**\n * Returns the instance of  given command.\n *\n * @param {String} cmd\n * @return {Command}\n * @api public\n */\n\nvorpal.find = function (name) {\n  return _.find(this.commands, { _name: name });\n};\n\n/**\n * Registers custom help.\n *\n * @param {Function} fn\n * @return {Vorpal}\n * @api public\n */\n\nvorpal.help = function (fn) {\n  this._help = fn;\n};\n\n/**\n * Returns help string for a given command.\n *\n * @param {String} command\n * @api private\n */\n\nvorpal._commandHelp = function (command) {\n  if (!this.commands.length) {\n    return '';\n  }\n\n  if (this._help !== undefined && _.isFunction(this._help)) {\n    return this._help(command);\n  }\n\n  var matches = [];\n  var singleMatches = [];\n\n  command = command ? String(command).trim().toLowerCase() : undefined;\n  for (var i = 0; i < this.commands.length; ++i) {\n    var parts = String(this.commands[i]._name).split(' ');\n    if (parts.length === 1 && parts[0] === command && !this.commands[i]._hidden && !this.commands[i]._catch) {\n      singleMatches.push(command);\n    }\n    var str = '';\n    for (var j = 0; j < parts.length; ++j) {\n      str = String(str + ' ' + parts[j]).trim();\n      if (str === command && !this.commands[i]._hidden && !this.commands[i]._catch) {\n        matches.push(this.commands[i]);\n        break;\n      }\n    }\n  }\n\n  var invalidString = command && matches.length === 0 && singleMatches.length === 0 ? ['', '  Invalid Command. Showing Help:', ''].join('\\n') : '';\n\n  var commandMatch = matches.length > 0;\n  var commandMatchLength = commandMatch ? String(command).trim().split(' ').length + 1 : 1;\n  matches = matches.length === 0 ? this.commands : matches;\n\n  var skipGroups = !(matches.length + 6 > process.stdout.rows);\n\n  var commands = matches.filter(function (cmd) {\n    return !cmd._noHelp;\n  }).filter(function (cmd) {\n    return !cmd._catch;\n  }).filter(function (cmd) {\n    return !cmd._hidden;\n  }).filter(function (cmd) {\n    if (skipGroups === true) {\n      return true;\n    }\n    return String(cmd._name).trim().split(' ').length <= commandMatchLength;\n  }).map(function (cmd) {\n    var args = cmd._args.map(function (arg) {\n      return VorpalUtil.humanReadableArgName(arg);\n    }).join(' ');\n\n    return [cmd._name + (cmd._alias ? '|' + cmd._alias : '') + (cmd.options.length ? ' [options]' : '') + ' ' + args, cmd.description() || ''];\n  });\n\n  var width = commands.reduce(function (max, commandX) {\n    return Math.max(max, commandX[0].length);\n  }, 0);\n\n  var counts = {};\n\n  var groups = _.uniq(matches.filter(function (cmd) {\n    return String(cmd._name).trim().split(' ').length > commandMatchLength;\n  }).map(function (cmd) {\n    return String(cmd._name).split(' ').slice(0, commandMatchLength).join(' ');\n  }).map(function (cmd) {\n    counts[cmd] = counts[cmd] || 0;\n    counts[cmd]++;\n    return cmd;\n  })).map(function (cmd) {\n    var prefix = '    ' + VorpalUtil.pad(cmd + ' *', width) + '  ' + counts[cmd] + ' sub-command' + (counts[cmd] === 1 ? '' : 's') + '.';\n    return prefix;\n  });\n\n  groups = skipGroups ? [] : groups;\n\n  var descriptionWidth = process.stdout.columns - (width + 4);\n\n  var commandsString = commands.length < 1 ? '' : '\\n  Commands:\\n\\n' + commands.map(function (cmd) {\n    var prefix = '    ' + VorpalUtil.pad(cmd[0], width) + '  ';\n    var suffix = wrap(cmd[1], descriptionWidth - 8).split('\\n');\n    for (var _i = 0; _i < suffix.length; ++_i) {\n      if (_i !== 0) {\n        suffix[_i] = VorpalUtil.pad('', width + 6) + suffix[_i];\n      }\n    }\n    suffix = suffix.join('\\n');\n    return prefix + suffix;\n  }).join('\\n') + '\\n\\n';\n\n  var groupsString = groups.length < 1 ? '' : '  Command Groups:\\n\\n' + groups.join('\\n') + '\\n';\n\n  var results = String(invalidString + commandsString + '\\n' + groupsString).replace(/\\n\\n\\n/g, '\\n\\n').replace(/\\n\\n$/, '\\n');\n\n  return results;\n};\n\n/**\n * Abstracts the logic for sending and\n * receiving sockets upstream and downstream.\n *\n * To do: Has the start of logic for vorpal sessions,\n * which I haven't fully confronted yet.\n *\n * @param {String} str\n * @param {String} direction\n * @param {String} data\n * @param {Object} options\n * @api private\n */\n\nvorpal._send = function (str, direction, data, options) {\n  options = options || {};\n  data = data || {};\n  var ssn = this.getSessionById(data.sessionId);\n  if (!ssn) {\n    throw new Error('No Sessions logged for ID ' + data.sessionId + ' in vorpal._send.');\n  }\n  if (direction === 'upstream') {\n    if (ssn.client) {\n      ssn.client.emit(str, data);\n    }\n  } else if (direction === 'downstream') {\n    if (ssn.server) {\n      ssn.server.emit(str, data);\n    }\n  }\n};\n\n/**\n * Handles the 'middleman' in a 3+-way vagrant session.\n * If a vagrant instance is a 'client' and 'server', it is\n * now considered a 'proxy' and its sole purpose is to proxy\n * information through, upstream or downstream.\n *\n * If vorpal is not a proxy, it resolves a promise for further\n * code that assumes one is now an end user. If it ends up\n * piping the traffic through, it never resolves the promise.\n *\n * @param {String} str\n * @param {String} direction\n * @param {String} data\n * @param {Object} options\n * @api private\n */\nvorpal._proxy = function (str, direction, data, options) {\n  var self = this;\n  return new Promise(function (resolve) {\n    var ssn = self.getSessionById(data.sessionId);\n    if (ssn && !ssn.isLocal() && ssn.client) {\n      self._send(str, direction, data, options);\n    } else {\n      resolve();\n    }\n  });\n};\n\n/**\n * Returns session by id.\n *\n * @param {Integer} id\n * @return {Session}\n * @api public\n */\n\nvorpal.getSessionById = function (id) {\n  if (_.isObject(id)) {\n    throw new Error('vorpal.getSessionById: id ' + JSON.stringify(id) + ' should not be an object.');\n  }\n  var ssn = _.find(this.server.sessions, { id: id });\n  ssn = this.session.id === id ? this.session : ssn;\n  if (!id) {\n    throw new Error('vorpal.getSessionById was called with no ID passed.');\n  }\n  if (!ssn) {\n    var sessions = {\n      local: this.session.id,\n      server: _.map(this.server.sessions, 'id')\n    };\n    throw new Error('No session found for id ' + id + ' in vorpal.getSessionById. Sessions: ' + JSON.stringify(sessions));\n  }\n  return ssn;\n};\n\n/**\n * Kills a remote vorpal session. If user\n * is running on a direct terminal, will kill\n * node instance after confirmation.\n *\n * @param {Object} options\n * @param {Function} cb\n * @api private\n */\n\nvorpal.exit = function (options) {\n  var ssn = this.getSessionById(options.sessionId);\n  this.emit('vorpal_exit');\n  if (ssn.isLocal()) {\n    process.exit(0);\n  } else {\n    ssn.server.emit('vantage-close-downstream', { sessionId: ssn.id });\n  }\n};\n\nObject.defineProperty(vorpal, 'activeCommand', {\n  get: function get() {\n    var result = this._command ? this._command.commandInstance : undefined;\n    return result;\n  }\n});","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/command.js":"'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Option = require('./option');\nvar VorpalUtil = require('./util');\nvar _ = require('lodash');\n\n/**\n * Command prototype.\n */\n\nvar command = Command.prototype;\n\n/**\n * Expose `Command`.\n */\n\nmodule.exports = exports = Command;\n\n/**\n * Initialize a new `Command` instance.\n *\n * @param {String} name\n * @param {Vorpal} parent\n * @return {Command}\n * @api public\n */\n\nfunction Command(name, parent) {\n  if (!(this instanceof Command)) {\n    return new Command();\n  }\n  this.commands = [];\n  this.options = [];\n  this._args = [];\n  this._aliases = [];\n  this._name = name;\n  this._relay = false;\n  this._hidden = false;\n  this._parent = parent;\n  this._mode = false;\n  this._catch = false;\n  this._help = undefined;\n  this._init = undefined;\n  this._after = undefined;\n  this._allowUnknownOptions = false;\n}\n\n/**\n * Registers an option for given command.\n *\n * @param {String} flags\n * @param {String} description\n * @param {Function} fn\n * @param {String} defaultValue\n * @return {Command}\n * @api public\n */\n\ncommand.option = function (flags, description, autocomplete) {\n  var self = this;\n  var option = new Option(flags, description, autocomplete);\n  var oname = option.name();\n  var name = _camelcase(oname);\n  var defaultValue;\n\n  // preassign default value only for --no-*, [optional], or <required>\n  if (option.bool === false || option.optional || option.required) {\n    // when --no-* we make sure default is true\n    if (option.bool === false) {\n      defaultValue = true;\n    }\n    // preassign only if we have a default\n    if (defaultValue !== undefined) {\n      self[name] = defaultValue;\n    }\n  }\n\n  // register the option\n  this.options.push(option);\n\n  // when it's passed assign the value\n  // and conditionally invoke the callback\n  this.on(oname, function (val) {\n    // unassigned or bool\n    if (typeof self[name] === 'boolean' || typeof self[name] === 'undefined') {\n      // if no value, bool true, and we have a default, then use it!\n      if (val === null) {\n        self[name] = option.bool ? defaultValue || true : false;\n      } else {\n        self[name] = val;\n      }\n    } else if (val !== null) {\n      // reassign\n      self[name] = val;\n    }\n  });\n\n  return this;\n};\n\n/**\n * Defines an action for a given command.\n *\n * @param {Function} fn\n * @return {Command}\n * @api public\n */\n\ncommand.action = function (fn) {\n  var self = this;\n  self._fn = fn;\n  return this;\n};\n\n/**\n * Let's you compose other funtions to extend the command.\n *\n * @param {Function} fn\n * @return {Command}\n * @api public\n */\n\ncommand.use = function (fn) {\n  return fn(this);\n};\n\n/**\n * Defines a function to validate arguments\n * before action is performed. Arguments\n * are valid if no errors are thrown from\n * the function.\n *\n * @param fn\n * @returns {Command}\n * @api public\n */\ncommand.validate = function (fn) {\n  var self = this;\n  self._validate = fn;\n  return this;\n};\n\n/**\n * Defines a function to be called when the\n * command is canceled.\n *\n * @param fn\n * @returns {Command}\n * @api public\n */\ncommand.cancel = function (fn) {\n  this._cancel = fn;\n  return this;\n};\n\n/**\n * Defines a method to be called when\n * the command set has completed.\n *\n * @param {Function} fn\n * @return {Command}\n * @api public\n */\n\ncommand.done = function (fn) {\n  this._done = fn;\n  return this;\n};\n\n/**\n * Defines tabbed auto-completion\n * for the given command. Favored over\n * deprecated command.autocompletion.\n *\n * @param {Function} fn\n * @return {Command}\n * @api public\n */\n\ncommand.autocomplete = function (obj) {\n  this._autocomplete = obj;\n  return this;\n};\n\n/**\n * Defines tabbed auto-completion rules\n * for the given command.\n *\n * @param {Function} fn\n * @return {Command}\n * @api public\n */\n\ncommand.autocompletion = function (param) {\n  this._parent._useDeprecatedAutocompletion = true;\n  if (!_.isFunction(param) && !_.isObject(param)) {\n    throw new Error('An invalid object type was passed into the first parameter of command.autocompletion: function expected.');\n  }\n\n  this._autocompletion = param;\n  return this;\n};\n\n/**\n * Defines an init action for a mode command.\n *\n * @param {Function} fn\n * @return {Command}\n * @api public\n */\n\ncommand.init = function (fn) {\n  var self = this;\n  if (self._mode !== true) {\n    throw Error('Cannot call init from a non-mode action.');\n  }\n  self._init = fn;\n  return this;\n};\n\n/**\n * Defines a prompt delimiter for a\n * mode once entered.\n *\n * @param {String} delimiter\n * @return {Command}\n * @api public\n */\n\ncommand.delimiter = function (delimiter) {\n  this._delimiter = delimiter;\n  return this;\n};\n\n/**\n * Sets args for static typing of options\n * using minimist.\n *\n * @param {Object} types\n * @return {Command}\n * @api public\n */\n\ncommand.types = function (types) {\n  var supported = ['string', 'boolean'];\n  for (var item in types) {\n    if (supported.indexOf(item) === -1) {\n      throw new Error('An invalid type was passed into command.types(): ' + item);\n    }\n    types[item] = !_.isArray(types[item]) ? [types[item]] : types[item];\n  }\n  this._types = types;\n  return this;\n};\n\n/**\n * Defines an alias for a given command.\n *\n * @param {String} alias\n * @return {Command}\n * @api public\n */\n\ncommand.alias = function () {\n  var self = this;\n  for (var i = 0; i < arguments.length; ++i) {\n    var alias = arguments[i];\n    if (_.isArray(alias)) {\n      for (var j = 0; j < alias.length; ++j) {\n        this.alias(alias[j]);\n      }\n      return this;\n    }\n    this._parent.commands.forEach(function (cmd) {\n      if (!_.isEmpty(cmd._aliases)) {\n        if (_.includes(cmd._aliases, alias)) {\n          var msg = 'Duplicate alias \"' + alias + '\" for command \"' + self._name + '\" detected. Was first reserved by command \"' + cmd._name + '\".';\n          throw new Error(msg);\n        }\n      }\n    });\n    this._aliases.push(alias);\n  }\n  return this;\n};\n\n/**\n * Defines description for given command.\n *\n * @param {String} str\n * @return {Command}\n * @api public\n */\n\ncommand.description = function (str) {\n  if (arguments.length === 0) {\n    return this._description;\n  }\n  this._description = str;\n  return this;\n};\n\n/**\n * Removes self from Vorpal instance.\n *\n * @return {Command}\n * @api public\n */\n\ncommand.remove = function () {\n  var self = this;\n  this._parent.commands = _.reject(this._parent.commands, function (command) {\n    if (command._name === self._name) {\n      return true;\n    }\n  });\n  return this;\n};\n\n/**\n * Returns the commands arguments as string.\n *\n * @param {String} desc\n * @return {String}\n * @api public\n */\n\ncommand.arguments = function (desc) {\n  return this._parseExpectedArgs(desc.split(/ +/));\n};\n\n/**\n * Returns the help info for given command.\n *\n * @return {String}\n * @api public\n */\n\ncommand.helpInformation = function () {\n  var desc = [];\n  var cmdName = this._name;\n  var alias = '';\n\n  if (this._description) {\n    desc = ['  ' + this._description, ''];\n  }\n\n  if (this._aliases.length > 0) {\n    alias = '  Alias: ' + this._aliases.join(' | ') + '\\n';\n  }\n  var usage = ['', '  Usage: ' + cmdName + ' ' + this.usage(), ''];\n\n  var cmds = [];\n\n  var help = String(this.optionHelp().replace(/^/gm, '    '));\n  var options = ['  Options:', '', help, ''];\n\n  var res = usage.concat(cmds).concat(alias).concat(desc).concat(options).join('\\n');\n\n  res = res.replace(/\\n\\n\\n/g, '\\n\\n');\n\n  return res;\n};\n\n/**\n * Doesn't show command in the help menu.\n *\n * @return {Command}\n * @api public\n */\n\ncommand.hidden = function () {\n  this._hidden = true;\n  return this;\n};\n\n/**\n * Allows undeclared options to be passed in with the command.\n *\n * @param {Boolean} [allowUnknownOptions=true]\n * @return {Command}\n * @api public\n */\n\ncommand.allowUnknownOptions = function () {\n  var allowUnknownOptions = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n  allowUnknownOptions = allowUnknownOptions === \"false\" ? false : allowUnknownOptions;\n\n  this._allowUnknownOptions = !!allowUnknownOptions;\n  return this;\n};\n\n/**\n * Returns the command usage string for help.\n *\n * @param {String} str\n * @return {String}\n * @api public\n */\n\ncommand.usage = function (str) {\n  var args = this._args.map(function (arg) {\n    return VorpalUtil.humanReadableArgName(arg);\n  });\n\n  var usage = '[options]' + (this.commands.length ? ' [command]' : '') + (this._args.length ? ' ' + args.join(' ') : '');\n\n  if (arguments.length === 0) {\n    return this._usage || usage;\n  }\n\n  this._usage = str;\n\n  return this;\n};\n\n/**\n * Returns the help string for the command's options.\n *\n * @return {String}\n * @api public\n */\n\ncommand.optionHelp = function () {\n  var width = this._largestOptionLength();\n\n  // Prepend the help information\n  return [VorpalUtil.pad('--help', width) + '  output usage information'].concat(this.options.map(function (option) {\n    return VorpalUtil.pad(option.flags, width) + '  ' + option.description;\n  })).join('\\n');\n};\n\n/**\n * Returns the length of the longest option.\n *\n * @return {Integer}\n * @api private\n */\n\ncommand._largestOptionLength = function () {\n  return this.options.reduce(function (max, option) {\n    return Math.max(max, option.flags.length);\n  }, 0);\n};\n\n/**\n * Adds a custom handling for the --help flag.\n *\n * @param {Function} fn\n * @return {Command}\n * @api public\n */\n\ncommand.help = function (fn) {\n  if (_.isFunction(fn)) {\n    this._help = fn;\n  }\n  return this;\n};\n\n/**\n * Edits the raw command string before it\n * is executed.\n *\n * @param {String} str\n * @return {String} str\n * @api public\n */\n\ncommand.parse = function (fn) {\n  if (_.isFunction(fn)) {\n    this._parse = fn;\n  }\n  return this;\n};\n\n/**\n * Adds a command to be executed after command completion.\n *\n * @param {Function} fn\n * @return {Command}\n * @api public\n */\n\ncommand.after = function (fn) {\n  if (_.isFunction(fn)) {\n    this._after = fn;\n  }\n  return this;\n};\n\n/**\n * Parses and returns expected command arguments.\n *\n * @param {String} args\n * @return {Array}\n * @api private\n */\n\ncommand._parseExpectedArgs = function (args) {\n  if (!args.length) {\n    return;\n  }\n  var self = this;\n  args.forEach(function (arg) {\n    var argDetails = {\n      required: false,\n      name: '',\n      variadic: false\n    };\n\n    switch (arg[0]) {\n      case '<':\n        argDetails.required = true;\n        argDetails.name = arg.slice(1, -1);\n        break;\n      case '[':\n        argDetails.name = arg.slice(1, -1);\n        break;\n      default:\n        break;\n    }\n\n    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {\n      argDetails.variadic = true;\n      argDetails.name = argDetails.name.slice(0, -3);\n    }\n    if (argDetails.name) {\n      self._args.push(argDetails);\n    }\n  });\n\n  // If the user entered args in a weird order,\n  // properly sequence them.\n  if (self._args.length > 1) {\n    self._args = self._args.sort(function (argu1, argu2) {\n      if (argu1.required && !argu2.required) {\n        return -1;\n      } else if (argu2.required && !argu1.required) {\n        return 1;\n      } else if (argu1.variadic && !argu2.variadic) {\n        return 1;\n      } else if (argu2.variadic && !argu1.variadic) {\n        return -1;\n      }\n      return 0;\n    });\n  }\n\n  return;\n};\n\n/**\n * Converts string to camel case.\n *\n * @param {String} flag\n * @return {String}\n * @api private\n */\n\nfunction _camelcase(flag) {\n  return flag.split('-').reduce(function (str, word) {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Make command an EventEmitter.\n */\n\ncommand.__proto__ = EventEmitter.prototype;","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/option.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Option = function () {\n\n  /**\n   * Initialize a new `Option` instance.\n   *\n   * @param {String} flags\n   * @param {String} description\n   * @param {Autocomplete} autocomplete\n   * @return {Option}\n   * @api public\n   */\n\n  function Option(flags, description, autocomplete) {\n    _classCallCheck(this, Option);\n\n    this.flags = flags;\n    this.required = ~flags.indexOf('<');\n    this.optional = ~flags.indexOf('[');\n    this.bool = ! ~flags.indexOf('-no-');\n    this.autocomplete = autocomplete;\n    flags = flags.split(/[ ,|]+/);\n    if (flags.length > 1 && !/^[[<]/.test(flags[1])) {\n      this.assignFlag(flags.shift());\n    }\n    this.assignFlag(flags.shift());\n    this.description = description || '';\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {String}\n   * @api private\n   */\n\n  _createClass(Option, [{\n    key: 'name',\n    value: function name() {\n      if (this.long !== undefined) {\n        return this.long.replace('--', '').replace('no-', '');\n      }\n      return this.short.replace('-', '');\n    }\n\n    /**\n     * Check if `arg` matches the short or long flag.\n     *\n     * @param {String} arg\n     * @return {Boolean}\n     * @api private\n     */\n\n  }, {\n    key: 'is',\n    value: function is(arg) {\n      return arg === this.short || arg === this.long;\n    }\n\n    /**\n     * Assigned flag to either long or short.\n     *\n     * @param {String} flag\n     * @api private\n     */\n\n  }, {\n    key: 'assignFlag',\n    value: function assignFlag(flag) {\n      if (flag.startsWith('--')) {\n        this.long = flag;\n      } else {\n        this.short = flag;\n      }\n    }\n  }]);\n\n  return Option;\n}();\n\n/**\n * Expose `Option`.\n */\n\nmodule.exports = exports = Option;","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/util.js":"'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _ = require('lodash');\nvar minimist = require('minimist');\nvar strip = require('strip-ansi');\n\nvar util = {\n  /**\n   * Parses command arguments from multiple\n   * sources.\n   *\n   * @param {String} str\n   * @param {Object} opts\n   * @return {Array}\n   * @api private\n   */\n\n  parseArgs: function parseArgs(str, opts) {\n    var reg = /\"(.*?)\"|'(.*?)'|`(.*?)`|([^\\s\"]+)/gi;\n    var arr = [];\n    var match = undefined;\n    do {\n      match = reg.exec(str);\n      if (match !== null) {\n        arr.push(match[1] || match[2] || match[3] || match[4]);\n      }\n    } while (match !== null);\n\n    arr = minimist(arr, opts);\n    arr._ = arr._ || [];\n    return arr;\n  },\n\n  /**\n   * Prepares a command and all its parts for execution.\n   *\n   * @param {String} command\n   * @param {Array} commands\n   * @return {Object}\n   * @api public\n   */\n\n  parseCommand: function parseCommand(command, commands) {\n    var self = this;\n    var pipes = [];\n    var match = undefined;\n    var matchArgs = undefined;\n    var matchParts = undefined;\n\n    function parsePipes() {\n      // First, split the command by pipes naively.\n      // This will split command arguments in half when the argument contains a pipe character.\n      // For example, say \"(Vorpal|vorpal)\" will be split into ['say \"(Vorpal', 'vorpal)'] which isn't good.\n      var naivePipes = String(command).trim().split('|');\n\n      // Contruct empty array to place correctly split commands into.\n      var newPipes = [];\n\n      // We will look for pipe characters within these quotes to rejoin together.\n      var quoteChars = ['\"', '\\'', '`'];\n\n      // This will expand to contain one boolean key for each type of quote.\n      // The value keyed by the quote is toggled off and on as quote type is opened and closed.\n      // Example { \"`\": true, \"'\": false } would mean that there is an open angle quote.\n      var quoteTracker = {};\n\n      // The current command piece before being rejoined with it's over half.\n      // Since it's not common for pipes to occur in commands, this is usually the entire command pipe.\n      var commandPart = '';\n\n      // Loop through each naive pipe.\n      for (var key in naivePipes) {\n        // It's possible/likely that this naive pipe is the whole pipe if it doesn't contain an unfinished quote.\n        var possiblePipe = naivePipes[key];\n        commandPart += possiblePipe;\n\n        // Loop through each individual character in the possible pipe tracking the opening and closing of quotes.\n        for (var i = 0; i < possiblePipe.length; i++) {\n          var char = possiblePipe[i];\n          if (quoteChars.indexOf(char) !== -1) {\n            quoteTracker[char] = !quoteTracker[char];\n          }\n        }\n\n        // Does the pipe end on an unfinished quote?\n        var inQuote = _.some(quoteChars, function (quoteChar) {\n          return quoteTracker[quoteChar];\n        });\n\n        // If the quotes have all been closed or this is the last possible pipe in the array, add as pipe.\n        if (!inQuote || key * 1 === naivePipes.length - 1) {\n          newPipes.push(commandPart.trim());\n          commandPart = '';\n        } else {\n          // Quote was left open. The pipe character was previously removed when the array was split.\n          commandPart += '|';\n        }\n      }\n\n      // Set the first pipe to command and the rest to pipes.\n      command = newPipes.shift();\n      pipes = pipes.concat(newPipes);\n    }\n\n    function parseMatch() {\n      matchParts = self.matchCommand(command, commands);\n      match = matchParts.command;\n      matchArgs = matchParts.args;\n    }\n\n    parsePipes();\n    parseMatch();\n\n    if (match && _.isFunction(match._parse)) {\n      command = match._parse(command, matchParts.args);\n      parsePipes();\n      parseMatch();\n    }\n\n    return {\n      command: command,\n      match: match,\n      matchArgs: matchArgs,\n      pipes: pipes\n    };\n  },\n\n  /**\n   * Run a raw command string, e.g. foo -bar\n   * against a given list of commands,\n   * and if there is a match, parse the\n   * results.\n   *\n   * @param {String} cmd\n   * @param {Array} cmds\n   * @return {Object}\n   * @api public\n   */\n\n  matchCommand: function matchCommand(cmd, cmds) {\n    var parts = String(cmd).trim().split(' ');\n\n    var match = undefined;\n    var matchArgs = undefined;\n    for (var i = 0; i < parts.length; ++i) {\n      var subcommand = String(parts.slice(0, parts.length - i).join(' ')).trim();\n      match = _.find(cmds, { _name: subcommand }) || match;\n      if (!match) {\n        for (var key in cmds) {\n          var _cmd = cmds[key];\n          var idx = _cmd._aliases.indexOf(subcommand);\n          match = idx > -1 ? _cmd : match;\n        }\n      }\n      if (match) {\n        matchArgs = parts.slice(parts.length - i, parts.length).join(' ');\n        break;\n      }\n    }\n    // If there's no command match, check if the\n    // there's a `catch` command, which catches all\n    // missed commands.\n    if (!match) {\n      match = _.find(cmds, { _catch: true });\n      // If there is one, we still need to make sure we aren't\n      // partially matching command groups, such as `do things` when\n      // there is a command `do things well`. If we match partially,\n      // we still want to show the help menu for that command group.\n      if (match) {\n        var allCommands = _.map(cmds, '_name');\n        var wordMatch = false;\n        for (var key in allCommands) {\n          var _cmd2 = allCommands[key];\n          var parts2 = String(_cmd2).split(' ');\n          var cmdParts = String(match.command).split(' ');\n          var matchAll = true;\n          for (var k = 0; k < cmdParts.length; ++k) {\n            if (parts2[k] !== cmdParts[k]) {\n              matchAll = false;\n              break;\n            }\n          }\n          if (matchAll) {\n            wordMatch = true;\n            break;\n          }\n        }\n        if (wordMatch) {\n          match = undefined;\n        } else {\n          matchArgs = cmd;\n        }\n      }\n    }\n\n    return {\n      command: match,\n      args: matchArgs\n    };\n  },\n\n  buildCommandArgs: function buildCommandArgs(passedArgs, cmd, execCommand, isCommandArgKeyPairNormalized) {\n    var args = { options: {} };\n\n    if (isCommandArgKeyPairNormalized) {\n      // Normalize all foo=\"bar\" with \"foo='bar'\"\n      // This helps implement unix-like key value pairs.\n      var reg = /(['\"]?)(\\w+)=(?:(['\"])((?:(?!\\3).)*)\\3|(\\S+))\\1/g;\n      passedArgs = passedArgs.replace(reg, '\"$2=\\'$4$5\\'\"');\n    }\n\n    // Types are custom arg types passed\n    // into `minimist` as per its docs.\n    var types = cmd._types || {};\n\n    // Make a list of all boolean options\n    // registered for this command. These are\n    // simply commands that don't have required\n    // or optional args.\n    var booleans = [];\n    cmd.options.forEach(function (opt) {\n      if (opt.required === 0 && opt.optional === 0) {\n        if (opt.short) {\n          booleans.push(opt.short);\n        }\n        if (opt.long) {\n          booleans.push(opt.long);\n        }\n      }\n    });\n\n    // Review the args passed into the command,\n    // and filter out the boolean list to only those\n    // options passed in.\n    // This returns a boolean list of all options\n    // passed in by the caller, which don't have\n    // required or optional args.\n    var passedArgParts = passedArgs.split(' ');\n    types.boolean = booleans.map(function (str) {\n      return String(str).replace(/^-*/, '');\n    }).filter(function (str) {\n      var match = false;\n      var strings = ['-' + str, '--' + str, '--no-' + str];\n      for (var i = 0; i < passedArgParts.length; ++i) {\n        if (strings.indexOf(passedArgParts[i]) > -1) {\n          match = true;\n          break;\n        }\n      }\n      return match;\n    });\n\n    // Use minimist to parse the args.\n    var parsedArgs = this.parseArgs(passedArgs, types);\n\n    function validateArg(arg, cmdArg) {\n      return !(arg === undefined && cmdArg.required === true);\n    }\n\n    // Builds varidiac args and options.\n    var valid = true;\n    var remainingArgs = _.clone(parsedArgs._);\n    for (var l = 0; l < 10; ++l) {\n      var matchArg = cmd._args[l];\n      var passedArg = parsedArgs._[l];\n      if (matchArg !== undefined) {\n        valid = !valid ? false : validateArg(parsedArgs._[l], matchArg);\n        if (!valid) {\n          break;\n        }\n        if (passedArg !== undefined) {\n          if (matchArg.variadic === true) {\n            args[matchArg.name] = remainingArgs;\n          } else {\n            args[matchArg.name] = passedArg;\n            remainingArgs.shift();\n          }\n        }\n      }\n    }\n\n    if (!valid) {\n      return '\\n  Missing required argument. Showing Help:';\n    }\n\n    // Looks for ommitted required options and throws help.\n    for (var m = 0; m < cmd.options.length; ++m) {\n      var o = cmd.options[m];\n      var short = String(o.short || '').replace(/-/g, '');\n      var long = String(o.long || '').replace(/--no-/g, '').replace(/^-*/g, '');\n      var exist = parsedArgs[short] !== undefined ? parsedArgs[short] : undefined;\n      exist = exist === undefined && parsedArgs[long] !== undefined ? parsedArgs[long] : exist;\n      var existsNotSet = exist === true || exist === false;\n      if (existsNotSet && o.required !== 0) {\n        return '\\n  Missing required value for option ' + (o.long || o.short) + '. Showing Help:';\n      }\n      if (exist !== undefined) {\n        args.options[long || short] = exist;\n      }\n    }\n\n    // Looks for supplied options that don't\n    // exist in the options list.\n    // If the command allows unknown options,\n    // adds it, otherwise throws help.\n    var passedOpts = _.chain(parsedArgs).keys().pull('_').pull('help').value();\n\n    var _loop = function _loop(key) {\n      var opt = passedOpts[key];\n      var optionFound = _.find(cmd.options, function (expected) {\n        if ('--' + opt === expected.long || '--no-' + opt === expected.long || '-' + opt === expected.short) {\n          return true;\n        }\n        return false;\n      });\n      if (optionFound === undefined) {\n        if (cmd._allowUnknownOptions) {\n          args.options[opt] = parsedArgs[opt];\n        } else {\n          return {\n            v: '\\n  Invalid option: \\'' + opt + '\\'. Showing Help:'\n          };\n        }\n      }\n    };\n\n    for (var key in passedOpts) {\n      var _ret = _loop(key);\n\n      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n\n    // If args were passed into the programmatic\n    // `vorpal.exec(cmd, args, callback)`, merge\n    // them here.\n    if (execCommand && execCommand.args && _.isObject(execCommand.args)) {\n      args = _.extend(args, execCommand.args);\n    }\n\n    // Looks for a help arg and throws help if any.\n    if (parsedArgs.help || parsedArgs._.indexOf('/?') > -1) {\n      args.options.help = true;\n    }\n\n    return args;\n  },\n\n  /**\n   * Makes an argument name pretty for help.\n   *\n   * @param {String} arg\n   * @return {String}\n   * @api private\n   */\n\n  humanReadableArgName: function humanReadableArgName(arg) {\n    var nameOutput = arg.name + (arg.variadic === true ? '...' : '');\n    return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';\n  },\n\n  /**\n   * Formats an array to display in a TTY\n   * in a pretty fashion.\n   *\n   * @param {Array} arr\n   * @return {String}\n   * @api public\n   */\n\n  prettifyArray: function prettifyArray(arr) {\n    arr = arr || [];\n    var arrClone = _.clone(arr);\n    var width = process.stdout.columns;\n    var longest = strip(arrClone.sort(function (a, b) {\n      return strip(b).length - strip(a).length;\n    })[0] || '').length + 2;\n    var fullWidth = strip(String(arr.join(''))).length;\n    var fitsOneLine = fullWidth + arr.length * 2 <= width;\n    var cols = Math.floor(width / longest);\n    cols = cols < 1 ? 1 : cols;\n    if (fitsOneLine) {\n      return arr.join('  ');\n    }\n    var col = 0;\n    var lines = [];\n    var line = '';\n    for (var key in arr) {\n      var arrEl = arr[key];\n      if (col < cols) {\n        col++;\n      } else {\n        lines.push(line);\n        line = '';\n        col = 1;\n      }\n      line += this.pad(arrEl, longest, ' ');\n    }\n    if (line !== '') {\n      lines.push(line);\n    }\n    return lines.join('\\n');\n  },\n\n  /**\n   * Pads a value with with space or\n   * a specified delimiter to match a\n   * given width.\n   *\n   * @param {String} str\n   * @param {Integer} width\n   * @param {String} delimiter\n   * @return {String}\n   * @api private\n   */\n\n  pad: function pad(str, width, delimiter) {\n    width = Math.floor(width);\n    delimiter = delimiter || ' ';\n    var len = Math.max(0, width - strip(str).length);\n    return str + Array(len + 1).join(delimiter);\n  },\n\n  // When passing down applied args, we need to turn\n  // them from `{ '0': 'foo', '1': 'bar' }` into ['foo', 'bar']\n  // instead.\n  fixArgsForApply: function fixArgsForApply(obj) {\n    if (!_.isObject(obj)) {\n      if (!_.isArray(obj)) {\n        return [obj];\n      }\n      return obj;\n    }\n    var argArray = [];\n    for (var key in obj) {\n      var aarg = obj[key];\n      argArray.push(aarg);\n    }\n    return argArray;\n  }\n};\n\n/**\n * Expose `util`.\n */\n\nmodule.exports = exports = util;","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/command-instance.js":"'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar util = require('./util');\nvar _ = require('lodash');\n\nvar CommandInstance = function () {\n\n  /**\n   * Initialize a new `CommandInstance` instance.\n   *\n   * @param {Object} params\n   * @return {CommandInstance}\n   * @api public\n   */\n\n  function CommandInstance() {\n    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    var command = _ref.command;\n    var commandObject = _ref.commandObject;\n    var args = _ref.args;\n    var commandWrapper = _ref.commandWrapper;\n    var callback = _ref.callback;\n    var downstream = _ref.downstream;\n\n    _classCallCheck(this, CommandInstance);\n\n    this.command = command;\n    this.commandObject = commandObject;\n    this.args = args;\n    this.commandWrapper = commandWrapper;\n    this.session = commandWrapper.session;\n    this.parent = this.session.parent;\n    this.callback = callback;\n    this.downstream = downstream;\n  }\n\n  /**\n   * Cancel running command.\n   */\n\n  _createClass(CommandInstance, [{\n    key: 'cancel',\n    value: function cancel() {\n      this.session.emit('vorpal_command_cancel');\n    }\n\n    /**\n     * Route stdout either through a piped command, or the session's stdout.\n     */\n\n  }, {\n    key: 'log',\n    value: function log() {\n      var _this = this;\n\n      var args = util.fixArgsForApply(arguments);\n      if (this.downstream) {\n        var fn = this.downstream.commandObject._fn || function () {};\n        this.session.registerCommand();\n        this.downstream.args.stdin = args;\n        var onComplete = function onComplete(err) {\n          if (_this.session.isLocal() && err) {\n            _this.session.log(err.stack || err);\n            _this.session.parent.emit('client_command_error', { command: _this.downstream.command, error: err });\n          }\n          _this.session.completeCommand();\n        };\n\n        var validate = this.downstream.commandObject._validate;\n        if (_.isFunction(validate)) {\n          try {\n            validate.call(this.downstream, this.downstream.args);\n          } catch (e) {\n            // Log error without piping to downstream on validation error.\n            this.session.log(e.toString());\n            onComplete();\n            return;\n          }\n        }\n\n        var res = fn.call(this.downstream, this.downstream.args, onComplete);\n        if (res && _.isFunction(res.then)) {\n          res.then(onComplete, onComplete);\n        }\n      } else {\n        this.session.log.apply(this.session, args);\n      }\n    }\n  }, {\n    key: 'prompt',\n    value: function prompt(a, b, c) {\n      return this.session.prompt(a, b, c);\n    }\n  }, {\n    key: 'delimiter',\n    value: function delimiter(a, b, c) {\n      return this.session.delimiter(a, b, c);\n    }\n  }, {\n    key: 'help',\n    value: function help(a, b, c) {\n      return this.session.help(a, b, c);\n    }\n  }, {\n    key: 'match',\n    value: function match(a, b, c) {\n      return this.session.match(a, b, c);\n    }\n  }]);\n\n  return CommandInstance;\n}();\n\nmodule.exports = CommandInstance;","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/ui.js":"'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _ = require('lodash');\nvar inquirer = require('inquirer');\nvar EventEmitter = require('events').EventEmitter;\nvar chalk = require('chalk');\nvar util = require('./util');\nvar logUpdate = require('log-update');\n\nvar UI = function (_EventEmitter) {\n  _inherits(UI, _EventEmitter);\n\n  /**\n   * Sets intial variables and registers\n   * listeners. This is called once in a\n   * process thread regardless of how many\n   * instances of Vorpal have been generated.\n   *\n   * @api private\n   */\n\n  function UI() {\n    _classCallCheck(this, UI);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(UI).call(this));\n\n    var self = _this;\n\n    // Attached vorpal instance. The UI can\n    // only attach to one instance of Vorpal\n    // at a time, and directs all events to that\n    // instance.\n    _this.parent = undefined;\n\n    // Hook to reference active inquirer prompt.\n    _this._activePrompt = undefined;\n\n    // Fail-safe to ensure there is no double\n    // prompt in odd situations.\n    _this._midPrompt = false;\n\n    // Handle for inquirer's prompt.\n    _this.inquirer = inquirer;\n\n    // prompt history from inquirer\n    _this.inquirerStdout = [];\n\n    // Whether a prompt is currently in cancel mode.\n    _this._cancelled = false;\n\n    // Middleware for piping stdout through.\n    _this._pipeFn = undefined;\n\n    // Custom function on sigint event.\n    _this._sigintCalled = false;\n    _this._sigintCount = 0;\n    _this._sigint = function () {\n      if (_this._sigintCount > 1) {\n        _this.parent.emit('vorpal_exit');\n        process.exit(0);\n      } else {\n        var text = _this.input();\n        if (!_this.parent) {\n          // If Vorpal isn't shown, just exit.\n          process.exit(0);\n        } else if (_this.parent.session.cancelCommands) {\n          // There are commands running if\n          // cancelCommands function is available.\n          _this.imprint();\n          _this.submit('');\n          _this._sigintCalled = false;\n          _this._sigintCount = 0;\n          _this.parent.session.emit('vorpal_command_cancel');\n        } else if (String(text).trim() !== '') {\n          _this.imprint();\n          _this.submit('');\n          _this._sigintCalled = false;\n          _this._sigintCount = 0;\n        } else {\n          _this._sigintCalled = false;\n          _this.delimiter(' ');\n          _this.submit('');\n          _this.log('(^C again to quit)');\n        }\n      }\n    };\n\n    process.stdin.on('keypress', function (letter, key) {\n      key = key || {};\n      if (key.ctrl === true && key.shift === false && key.meta === false && ['c', 'C'].indexOf(key.name) > -1) {\n        _this._sigintCount++;\n        if (_this._sigint !== undefined && !_this._sigintCalled) {\n          _this._sigintCalled = true;\n          _this._sigint.call(self.parent);\n          _this._sigintCalled = false;\n        }\n      } else {\n        _this._sigintCalled = false;\n        _this._sigintCount = 0;\n      }\n    });\n\n    // Extend the render function to steal the active prompt object,\n    // as inquirer doesn't expose it and we need it.\n    var prompts = ['input', 'checkbox', 'confirm', 'expand', 'list', 'password', 'rawlist'];\n\n    var _loop = function _loop(key) {\n      var promptType = prompts[key];\n\n      // Add method to Inquirer to get type of prompt.\n      inquirer.prompt.prompts[promptType].prototype.getType = function () {\n        return promptType;\n      };\n\n      // Hook in to steal Inquirer's keypress.\n      inquirer.prompt.prompts[promptType].prototype.onKeypress = function (e) {\n        // Inquirer seems to have a bug with release v0.10.1\n        // (not 0.10.0 though) that triggers keypresses for\n        // the previous prompt in addition to the current one.\n        // So if the prompt is answered, shut it up.\n        if (this.status && this.status === 'answered') {\n          return;\n        }\n        self._activePrompt = this;\n        self.parent.emit('client_keypress', e);\n        self._keypressHandler(e, this);\n      };\n\n      // Add hook to render method.\n      var render = inquirer.prompt.prompts[promptType].prototype.render;\n      inquirer.prompt.prompts[promptType].prototype.render = function () {\n        self._activePrompt = this;\n        return render.apply(this, arguments);\n      };\n    };\n\n    for (var key in prompts) {\n      _loop(key);\n    }\n\n    // Sigint handling - make it more graceful.\n    var onSigInt = function onSigInt() {\n      if (_.isFunction(_this._sigint) && !_this._sigintCalled) {\n        _this._sigintCalled = true;\n        _this._sigint.call(_this.parent);\n      }\n    };\n    process.on('SIGINT', onSigInt);\n    process.on('SIGTERM', onSigInt);\n    return _this;\n  }\n\n  /**\n   * Hook for sigint event.\n   *\n   * @param {Object} options\n   * @param {Function} cb\n   * @api public\n   */\n\n  _createClass(UI, [{\n    key: 'sigint',\n    value: function sigint(fn) {\n      if (_.isFunction(fn)) {\n        this._sigint = fn;\n      } else {\n        throw new Error('vorpal.ui.sigint must be passed in a valid function.');\n      }\n      return this;\n    }\n\n    /**\n     * Creates an inquirer prompt on the TTY.\n     *\n     * @param {Object} options\n     * @param {Function} cb\n     * @api public\n     */\n\n  }, {\n    key: 'prompt',\n    value: function prompt(options, cb) {\n      var _this2 = this;\n\n      var prompt = undefined;\n      options = options || {};\n      if (!this.parent) {\n        return prompt;\n      }\n      if (options.delimiter) {\n        this.setDelimiter(options.delimiter);\n      }\n      if (options.message) {\n        this.setDelimiter(options.message);\n      }\n      if (this._midPrompt) {\n        console.log('Prompt called when mid prompt...');\n        throw new Error('UI Prompt called when already mid prompt.');\n      }\n      this._midPrompt = true;\n      try {\n        prompt = inquirer.prompt(options, function (result) {\n          _this2.inquirerStdout = [];\n          _this2._midPrompt = false;\n          if (_this2._cancel === true) {\n            _this2._cancel = false;\n          } else {\n            cb(result);\n          }\n        });\n\n        // Temporary hack. We need to pull the active\n        // prompt from inquirer as soon as possible,\n        // however we can't just assign it sync, as\n        // the prompt isn't ready yet.\n        // I am trying to get inquirer extended to\n        // fire an event instead.\n        setTimeout(function () {\n          // this._activePrompt = prompt._activePrompt;\n        }, 100);\n      } catch (e) {\n        console.log('Vorpal Prompt error:', e);\n      }\n      return prompt;\n    }\n\n    /**\n     * Returns a boolean as to whether user\n     * is mid another pr ompt.\n     *\n     * @return {Boolean}\n     * @api public\n     */\n\n  }, {\n    key: 'midPrompt',\n    value: function midPrompt() {\n      var mid = this._midPrompt === true && this.parent !== undefined;\n      return mid;\n    }\n  }, {\n    key: 'setDelimiter',\n    value: function setDelimiter(str) {\n      var self = this;\n      if (!this.parent) {\n        return;\n      }\n      str = String(str).trim() + ' ';\n      this._lastDelimiter = str;\n      inquirer.prompt.prompts.password.prototype.getQuestion = function () {\n        self._activePrompt = this;\n        return this.opt.message;\n      };\n      inquirer.prompt.prompts.input.prototype.getQuestion = function () {\n        self._activePrompt = this;\n        var message = this.opt.message;\n        if ((this.opt.default || this.opt.default === false) && this.status !== 'answered') {\n          message += chalk.dim('(' + this.opt.default + ') ');\n        }\n        self.inquirerStdout.push(message);\n        return message;\n      };\n    }\n\n    /**\n     * Event handler for keypresses - deals with command history\n     * and tabbed auto-completion.\n     *\n     * @param {Event} e\n     * @param {Prompt} prompt\n     * @api private\n     */\n\n  }, {\n    key: '_keypressHandler',\n    value: function _keypressHandler(e, prompt) {\n      // Remove tab characters from user input.\n      prompt.rl.line = prompt.rl.line.replace(/\\t+/, '');\n\n      // Mask passwords.\n      var line = prompt.getType() !== 'password' ? prompt.rl.line : '*'.repeat(prompt.rl.line.length);\n\n      // Re-write render function.\n      var width = prompt.rl.line.length;\n      var newWidth = prompt.rl.line.length;\n      var diff = newWidth - width;\n      prompt.rl.cursor += diff;\n      var cursor = 0;\n      var message = prompt.getQuestion();\n      var addition = prompt.status === 'answered' ? chalk.cyan(prompt.answer) : line;\n      message += addition;\n      prompt.screen.render(message, { cursor: cursor });\n\n      var key = (e.key || {}).name;\n      var value = prompt ? String(line) : undefined;\n      this.emit('vorpal_ui_keypress', { key: key, value: value, e: e });\n    }\n\n    /**\n     * Pauses active prompt, returning\n     * the value of what had been typed so far.\n     *\n     * @return {String} val\n     * @api public\n     */\n\n  }, {\n    key: 'pause',\n    value: function pause() {\n      if (!this.parent) {\n        return false;\n      }\n      if (!this._activePrompt) {\n        return false;\n      }\n      if (!this._midPrompt) {\n        return false;\n      }\n      var val = this._lastDelimiter + this._activePrompt.rl.line;\n      this._midPrompt = false;\n      var rl = this._activePrompt.screen.rl;\n      var screen = this._activePrompt.screen;\n      rl.output.unmute();\n      screen.clean();\n      rl.output.write('');\n      return val;\n    }\n\n    /**\n     * Resumes active prompt, accepting\n     * a string, which will fill the prompt\n     * with that text and put the cursor at\n     * the end.\n     *\n     * @param {String} val\n     * @api public\n     */\n\n  }, {\n    key: 'resume',\n    value: function resume(val) {\n      if (!this.parent) {\n        return this;\n      }\n      val = val || '';\n      if (!this._activePrompt) {\n        return this;\n      }\n      if (this._midPrompt) {\n        return this;\n      }\n      var rl = this._activePrompt.screen.rl;\n      rl.output.write(val);\n      this._midPrompt = true;\n      return this;\n    }\n\n    /**\n     * Cancels the active prompt, essentially\n     * but cutting out of the inquirer loop.\n     *\n     * @api public\n     */\n\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      if (this.midPrompt()) {\n        this._cancel = true;\n        this.submit('');\n        this._midPrompt = false;\n      }\n      return this;\n    }\n\n    /**\n     * Attaches TTY prompt to a given Vorpal instance.\n     *\n     * @param {Vorpal} vorpal\n     * @return {UI}\n     * @api public\n     */\n\n  }, {\n    key: 'attach',\n    value: function attach(vorpal) {\n      this.parent = vorpal;\n      this.refresh();\n      this.parent._prompt();\n      return this;\n    }\n\n    /**\n     * Detaches UI from a given Vorpal instance.\n     *\n     * @param {Vorpal} vorpal\n     * @return {UI}\n     * @api public\n     */\n\n  }, {\n    key: 'detach',\n    value: function detach(vorpal) {\n      if (vorpal === this.parent) {\n        this.parent = undefined;\n      }\n      return this;\n    }\n\n    /**\n     * Receives and runs logging through\n     * a piped function is one is provided\n     * through ui.pipe(). Pauses any active\n     * prompts, logs the data and then if\n     * paused, resumes the prompt.\n     *\n     * @return {UI}\n     * @api public\n     */\n\n  }, {\n    key: 'log',\n    value: function log() {\n      var args = util.fixArgsForApply(arguments);\n      args = _.isFunction(this._pipeFn) ? this._pipeFn(args) : args;\n      if (args === '') {\n        return this;\n      }\n      args = util.fixArgsForApply(args);\n      if (this.midPrompt()) {\n        var data = this.pause();\n        console.log.apply(console.log, args);\n        if (typeof data !== 'undefined' && data !== false) {\n          this.resume(data);\n        } else {\n          console.log('Log got back \\'false\\' as data. This shouldn\\'t happen.', data);\n        }\n      } else {\n        console.log.apply(console.log, args);\n      }\n      return this;\n    }\n\n    /**\n     * Submits a given prompt.\n     *\n     * @param {String} value\n     * @return {UI}\n     * @api public\n     */\n\n  }, {\n    key: 'submit',\n    value: function submit() {\n      if (this._activePrompt) {\n        // this._activePrompt.screen.onClose();\n        this._activePrompt.rl.emit('line');\n        // this._activePrompt.onEnd({isValid: true, value: value});\n        // to do - I don't know a good way to do this.\n      }\n      return this;\n    }\n\n    /**\n     * Does a literal, one-time write to the\n     * *current* prompt delimiter.\n     *\n     * @param {String} str\n     * @return {UI}\n     * @api public\n     */\n\n  }, {\n    key: 'delimiter',\n    value: function delimiter(str) {\n      if (!this._activePrompt) {\n        return this;\n      }\n      var prompt = this._activePrompt;\n      if (str === undefined) {\n        return prompt.opt.message;\n      }\n      prompt.opt.message = str;\n      this.refresh();\n      return this;\n    }\n\n    /**\n     * Re-writes the input of an Inquirer prompt.\n     * If no string is passed, it gets the current\n     * input.\n     *\n     * @param {String} str\n     * @return {String}\n     * @api public\n     */\n\n  }, {\n    key: 'input',\n    value: function input(str) {\n      if (!this._activePrompt) {\n        return undefined;\n      }\n      var prompt = this._activePrompt;\n      if (str === undefined) {\n        return prompt.rl.line;\n      }\n      var width = prompt.rl.line.length;\n      prompt.rl.line = str;\n      var newWidth = prompt.rl.line.length;\n      var diff = newWidth - width;\n      prompt.rl.cursor += diff;\n      var cursor = 0;\n      var message = prompt.getQuestion();\n      var addition = prompt.status === 'answered' ? chalk.cyan(prompt.answer) : prompt.rl.line;\n      message += addition;\n      prompt.screen.render(message, { cursor: cursor });\n      return this;\n    }\n\n    /**\n     * Logs the current delimiter and typed data.\n     *\n     * @return {UI}\n     * @api public\n     */\n\n  }, {\n    key: 'imprint',\n    value: function imprint() {\n      if (!this.parent) {\n        return this;\n      }\n      var val = this._activePrompt.rl.line;\n      var delimiter = this._lastDelimiter || this.delimiter() || '';\n      this.log(delimiter + val);\n      return this;\n    }\n\n    /**\n     * Redraws the inquirer prompt with a new string.\n     *\n     * @param {String} str\n     * @return {UI}\n     * @api private\n     */\n\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      if (!this.parent || !this._activePrompt) {\n        return this;\n      }\n      this._activePrompt.screen.clean();\n      this._activePrompt.render();\n      this._activePrompt.rl.output.write(this._activePrompt.rl.line);\n      return this;\n    }\n\n    /**\n     * Writes over existing logging.\n     *\n     * @param {String} str\n     * @return {UI}\n     * @api public\n     */\n\n  }, {\n    key: 'redraw',\n    value: function redraw(str) {\n      logUpdate(str);\n      return this;\n    }\n  }]);\n\n  return UI;\n}(EventEmitter);\n\n/**\n * Initialize singleton.\n */\n\nvar ui = new UI();\n\n/**\n * Clears logging from `ui.redraw`\n * permanently.\n *\n * @return {UI}\n * @api public\n */\n\nui.redraw.clear = function () {\n  logUpdate.clear();\n  return ui;\n};\n\n/**\n * Prints logging from `ui.redraw`\n * permanently.\n *\n * @return {UI}\n * @api public\n */\n\nui.redraw.done = function () {\n  logUpdate.done();\n  ui.refresh();\n  return ui;\n};\n\n/**\n * Expose `ui`.\n *\n * Modifying global? WTF?!? Yes. It is evil.\n * However node.js prompts are also quite\n * evil in a way. Nothing prevents dual prompts\n * between applications in the same terminal,\n * and inquirer doesn't catch or deal with this, so\n * if you want to start two independent instances of\n * vorpal, you need to know that prompt listeners\n * have already been initiated, and that you can\n * only attach the tty to one vorpal instance\n * at a time.\n * When you fire inqurier twice, you get a double-prompt,\n * where every keypress fires twice and it's just a\n * total mess. So forgive me.\n */\n\nglobal.__vorpal = global.__vorpal || {};\nglobal.__vorpal.ui = global.__vorpal.ui || {\n  exists: false,\n  exports: undefined\n};\n\nif (!global.__vorpal.ui.exists) {\n  global.__vorpal.ui.exists = true;\n  global.__vorpal.ui.exports = ui;\n  module.exports = exports = global.__vorpal.ui.exports;\n} else {\n  module.exports = global.__vorpal.ui.exports;\n}","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/session.js":"'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar os = require('os');\nvar _ = require('lodash');\nvar util = require('./util');\nvar autocomplete = require('./autocomplete');\nvar CommandInstance = require('./command-instance');\n\n/**\n * Initialize a new `Session` instance.\n *\n * @param {String} name\n * @return {Session}\n * @api public\n */\n\nfunction Session(options) {\n  options = options || {};\n  this.id = options.id || this._guid();\n  this.parent = options.parent || undefined;\n  this.authenticating = options.authenticating || false;\n  this.authenticated = options.authenticated || undefined;\n  this.user = options.user || 'guest';\n  this.host = options.host;\n  this.address = options.address || undefined;\n  this._isLocal = options.local || undefined;\n  this._delimiter = options.delimiter || String(os.hostname()).split('.')[0] + '~$';\n  this._modeDelimiter = undefined;\n\n  // Keeps history of how many times in a row `tab` was\n  // pressed on the keyboard.\n  this._tabCtr = 0;\n\n  this.cmdHistory = this.parent.cmdHistory;\n\n  // Special command mode vorpal is in at the moment,\n  // such as REPL. See mode documentation.\n  this._mode = undefined;\n\n  return this;\n}\n\n/**\n * Extend Session prototype as an event emitter.\n */\n\nSession.prototype = Object.create(EventEmitter.prototype);\n\n/**\n * Session prototype.\n */\n\nvar session = Session.prototype;\n\n/**\n * Expose `Session`.\n */\n\nmodule.exports = exports = Session;\n\n/**\n * Pipes logging data through any piped\n * commands, and then sends it to ._log for\n * actual logging.\n *\n * @param {String} [... arguments]\n * @return {Session}\n * @api public\n */\n\nsession.log = function () {\n  var args = util.fixArgsForApply(arguments);\n  return this._log.apply(this, args);\n};\n\n/**\n * Routes logging for a given session.\n * is on a local TTY, or remote.\n *\n * @param {String} [... arguments]\n * @return {Session}\n * @api public\n */\n\nsession._log = function () {\n  var self = this;\n  if (this.isLocal()) {\n    this.parent.ui.log.apply(this.parent.ui, arguments);\n  } else {\n    // If it's an error, expose the stack. Otherwise\n    // we get a helpful '{}'.\n    var args = [];\n    for (var i = 0; i < arguments.length; ++i) {\n      var str = arguments[i];\n      str = str && str.stack ? 'Error: ' + str.message : str;\n      args.push(str);\n    }\n    self.parent._send('vantage-ssn-stdout-downstream', 'downstream', { sessionId: self.id, value: args });\n  }\n  return this;\n};\n\n/**\n * Returns whether given session\n * is on a local TTY, or remote.\n *\n * @return {Boolean}\n * @api public\n */\n\nsession.isLocal = function () {\n  return this._isLocal;\n};\n\n/**\n * Maps to vorpal.prompt for a session\n * context.\n *\n * @param {Object} options\n * @param {Function} cb\n * @api public\n */\n\nsession.prompt = function (options, cb) {\n  options = options || {};\n  options.sessionId = this.id;\n  return this.parent.prompt(options, cb);\n};\n\n/**\n * Gets the full (normal + mode) delimiter\n * for this session.\n *\n * @return {String}\n * @api public\n */\n\nsession.fullDelimiter = function () {\n  var result = this._delimiter + (this._modeDelimiter !== undefined ? this._modeDelimiter : '');\n  return result;\n};\n\n/**\n * Sets the delimiter for this session.\n *\n * @param {String} str\n * @return {Session}\n * @api public\n */\n\nsession.delimiter = function (str) {\n  if (str === undefined) {\n    return this._delimiter;\n  }\n  this._delimiter = String(str).trim() + ' ';\n  if (this.isLocal()) {\n    this.parent.ui.refresh();\n  } else {\n    this.parent._send('vantage-delimiter-downstream', 'downstream', { value: str, sessionId: this.id });\n  }\n  return this;\n};\n\n/**\n * Sets the mode delimiter for this session.\n *\n * @param {String} str\n * @return {Session}\n * @api public\n */\n\nsession.modeDelimiter = function (str) {\n  var self = this;\n  if (str === undefined) {\n    return this._modeDelimiter;\n  }\n  if (!this.isLocal()) {\n    self.parent._send('vantage-mode-delimiter-downstream', 'downstream', { value: str, sessionId: self.id });\n  } else {\n    if (str === false || str === 'false') {\n      this._modeDelimiter = undefined;\n    } else {\n      this._modeDelimiter = String(str).trim() + ' ';\n    }\n    this.parent.ui.refresh();\n  }\n  return this;\n};\n\n/**\n * Returns the result of a keypress\n * string, depending on the type.\n *\n * @param {String} key\n * @param {String} value\n * @return {Function}\n * @api private\n */\n\nsession.getKeypressResult = function (key, value, cb) {\n  cb = cb || function () {};\n  var keyMatch = ['up', 'down', 'tab'].indexOf(key) > -1;\n  if (key !== 'tab') {\n    this._tabCtr = 0;\n  }\n  if (keyMatch) {\n    if (['up', 'down'].indexOf(key) > -1) {\n      cb(undefined, this.getHistory(key));\n    } else if (key === 'tab') {\n      // If the Vorpal user has any commands that use\n      // command.autocompletion, defer to the deprecated\n      // version of autocompletion. Otherwise, default\n      // to the new version.\n      var fn = this.parent._useDeprecatedAutocompletion ? 'getAutocompleteDeprecated' : 'getAutocomplete';\n      this[fn](value, function (err, data) {\n        cb(err, data);\n      });\n    }\n  } else {\n    this._histCtr = 0;\n  }\n};\n\nsession.history = function (str) {\n  var exceptions = [];\n  if (str && exceptions.indexOf(String(str).toLowerCase()) === -1) {\n    this.cmdHistory.newCommand(str);\n  }\n};\n\n/**\n * New autocomplete.\n *\n * @param {String} str\n * @param {Function} cb\n * @api private\n */\n\nsession.getAutocomplete = function (str, cb) {\n  return autocomplete.exec.call(this, str, cb);\n};\n\n/**\n * Deprecated autocomplete - being deleted\n * in Vorpal 2.0.\n *\n * @param {String} str\n * @param {Function} cb\n * @api private\n */\n\nsession.getAutocompleteDeprecated = function (str, cb) {\n  cb = cb || function () {};\n\n  // Entire command string\n  var cursor = this.parent.ui._activePrompt.screen.rl.cursor;\n  var trimmed = String(str).trim();\n  var cut = String(trimmed).slice(0, cursor);\n  var remainder = String(trimmed).slice(cursor, trimmed.length).replace(/ +$/, '');\n  trimmed = cut;\n\n  // Set \"trimmed\" to command string after pipe\n  // Set \"pre\" to command string, pipe, and a space\n  var pre = '';\n  var lastPipeIndex = trimmed.lastIndexOf('|');\n  if (lastPipeIndex !== -1) {\n    pre = trimmed.substr(0, lastPipeIndex + 1) + ' ';\n    trimmed = trimmed.substr(lastPipeIndex + 1).trim();\n  }\n\n  // Complete command\n  var names = _.map(this.parent.commands, '_name');\n  names = names.concat.apply(names, _.map(this.parent.commands, '_aliases'));\n  var result = this._autocomplete(trimmed, names);\n  if (result && trimmed.length < String(result).trim().length) {\n    cb(undefined, pre + result + remainder);\n    return;\n  }\n\n  // Find custom autocompletion\n  var match;\n  var extra;\n\n  names.forEach(function (name) {\n    if (trimmed.substr(0, name.length) === name && String(name).trim() !== '') {\n      match = name;\n      extra = trimmed.substr(name.length).trim();\n    }\n  });\n\n  var command = match ? _.find(this.parent.commands, { _name: match }) : undefined;\n\n  if (!command) {\n    command = _.find(this.parent.commands, { _catch: true });\n    if (command) {\n      extra = trimmed;\n    }\n  }\n\n  if (command && _.isFunction(command._autocompletion)) {\n    this._tabCtr++;\n    command._autocompletion.call(this, extra, this._tabCtr, function (err, autocomplete) {\n      if (err) {\n        return cb(err);\n      }\n      if (_.isArray(autocomplete)) {\n        return cb(undefined, autocomplete);\n      } else if (autocomplete === undefined) {\n        return cb(undefined, undefined);\n      }\n      return cb(undefined, pre + autocomplete + remainder);\n    });\n  } else {\n    cb(undefined, undefined);\n  }\n};\n\nsession._autocomplete = function (str, arr) {\n  return autocomplete.match.call(this, str, arr);\n};\n\n/**\n * Public facing autocomplete helper.\n *\n * @param {String} str\n * @param {Array} arr\n * @return {String}\n * @api public\n */\n\nsession.help = function (command) {\n  this.log(this.parent._commandHelp(command || ''));\n};\n\n/**\n * Public facing autocomplete helper.\n *\n * @param {String} str\n * @param {Array} arr\n * @return {String}\n * @api public\n */\n\nsession.match = function (str, arr) {\n  return this._autocomplete(str, arr);\n};\n\n/**\n * Gets a new command set ready.\n *\n * @return {session}\n * @api public\n */\n\nsession.execCommandSet = function (wrapper, callback) {\n  var self = this;\n  var response = {};\n  var res;\n  var cbk = callback;\n  this._registeredCommands = 1;\n  this._completedCommands = 0;\n\n  // Create the command instance for the first\n  // command and hook it up to the pipe chain.\n  var commandInstance = new CommandInstance({\n    downstream: wrapper.pipes[0],\n    commandObject: wrapper.commandObject,\n    commandWrapper: wrapper\n  });\n\n  wrapper.commandInstance = commandInstance;\n\n  function sendDones(itm) {\n    if (itm.commandObject && itm.commandObject._done) {\n      itm.commandObject._done.call(itm);\n    }\n    if (itm.downstream) {\n      sendDones(itm.downstream);\n    }\n  }\n\n  // Called when command is cancelled\n  this.cancelCommands = function () {\n    var callCancel = function callCancel(commandInstance) {\n      if (_.isFunction(commandInstance.commandObject._cancel)) {\n        commandInstance.commandObject._cancel.call(commandInstance);\n      }\n\n      if (commandInstance.downstream) {\n        callCancel(commandInstance.downstream);\n      }\n    };\n\n    callCancel(wrapper.commandInstance);\n\n    // Check if there is a cancel method on the promise\n    if (res && _.isFunction(res.cancel)) {\n      res.cancel(wrapper.commandInstance);\n    }\n\n    self.removeListener('vorpal_command_cancel', self.cancelCommands);\n    self.cancelCommands = undefined;\n    self._commandSetCallback = undefined;\n    self._registeredCommands = 0;\n    self._completedCommands = 0;\n    self.parent.emit('client_command_cancelled', { command: wrapper.command });\n\n    cbk(wrapper);\n  };\n\n  this.on('vorpal_command_cancel', self.cancelCommands);\n\n  // Gracefully handles all instances of the command completing.\n  this._commandSetCallback = function () {\n    var err = response.error;\n    var data = response.data;\n    var argus = response.args;\n    if (self.isLocal() && err) {\n      var stack;\n      if (data && data.stack) {\n        stack = data.stack;\n      } else if (err && err.stack) {\n        stack = err.stack;\n      } else {\n        stack = err;\n      }\n      self.log(stack);\n      self.parent.emit('client_command_error', { command: wrapper.command, error: err });\n    } else if (self.isLocal()) {\n      self.parent.emit('client_command_executed', { command: wrapper.command });\n    }\n\n    self.removeListener('vorpal_command_cancel', self.cancelCommands);\n    self.cancelCommands = undefined;\n    cbk(wrapper, err, data, argus);\n    sendDones(commandInstance);\n  };\n\n  function onCompletion(wrapper, err, data, argus) {\n    response = {\n      error: err,\n      data: data,\n      args: argus\n    };\n    self.completeCommand();\n  }\n\n  var valid;\n  if (_.isFunction(wrapper.validate)) {\n    try {\n      valid = wrapper.validate.call(commandInstance, wrapper.args);\n    } catch (e) {\n      // Complete with error on validation error\n      onCompletion(wrapper, e);\n      return this;\n    }\n  }\n\n  if (valid !== true && valid !== undefined) {\n    onCompletion(wrapper, valid || null);\n    return this;\n  }\n\n  // Call the root command.\n  res = wrapper.fn.call(commandInstance, wrapper.args, function () {\n    var argus = util.fixArgsForApply(arguments);\n    onCompletion(wrapper, argus[0], argus[1], argus);\n  });\n\n  // If the command as declared by the user\n  // returns a promise, handle accordingly.\n  if (res && _.isFunction(res.then)) {\n    res.then(function (data) {\n      onCompletion(wrapper, undefined, data);\n    }).catch(function (err) {\n      onCompletion(wrapper, true, err);\n    });\n  }\n\n  return this;\n};\n\n/**\n * Adds on a command or sub-command in progress.\n * Session keeps tracked of commands,\n * and as soon as all commands have been\n * compelted, the session returns the entire\n * command set as complete.\n *\n * @return {session}\n * @api public\n */\n\nsession.registerCommand = function () {\n  this._registeredCommands = this._registeredCommands || 0;\n  this._registeredCommands++;\n  return this;\n};\n\n/**\n * Marks a command or subcommand as having completed.\n * If all commands have completed, calls back\n * to the root command as being done.\n *\n * @return {session}\n * @api public\n */\n\nsession.completeCommand = function () {\n  this._completedCommands++;\n  if (this._registeredCommands <= this._completedCommands) {\n    this._registeredCommands = 0;\n    this._completedCommands = 0;\n    if (this._commandSetCallback) {\n      this._commandSetCallback();\n    }\n    this._commandSetCallback = undefined;\n  }\n  return this;\n};\n\n/**\n * Returns the appropriate command history\n * string based on an 'Up' or 'Down' arrow\n * key pressed by the user.\n *\n * @param {String} direction\n * @return {String}\n * @api private\n */\n\nsession.getHistory = function (direction) {\n  var history;\n  if (direction === 'up') {\n    history = this.cmdHistory.getPreviousHistory();\n  } else if (direction === 'down') {\n    history = this.cmdHistory.getNextHistory();\n  }\n  return history;\n};\n\n/**\n * Generates random GUID for Session ID.\n *\n * @return {GUID}\n * @api private\n */\n\nsession._guid = function () {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n};","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/autocomplete.js":"'use strict';\n\nvar _ = require('lodash');\nvar strip = require('strip-ansi');\n\nvar autocomplete = {\n\n  /**\n   * Handles tabbed autocompletion.\n   *\n   * - Initial tabbing lists all registered commands.\n   * - Completes a command halfway typed.\n   * - Recognizes options and lists all possible options.\n   * - Recognizes option arguments and lists them.\n   * - Supports cursor positions anywhere in the string.\n   * - Supports piping.\n   *\n   * @param {String} str\n   * @return {String} cb\n   * @api public\n   */\n\n  exec: function exec(str, cb) {\n    var self = this;\n    var input = parseInput(str, this.parent.ui._activePrompt.screen.rl.cursor);\n    var commands = getCommandNames(this.parent.commands);\n    var vorpalMatch = getMatch(input.context, commands, { ignoreSlashes: true });\n    var freezeTabs = false;\n\n    function end(str) {\n      var res = handleTabCounts.call(self, str, freezeTabs);\n      cb(undefined, res);\n    }\n\n    function evaluateTabs(input) {\n      if (input.context && input.context[input.context.length - 1] === '/') {\n        freezeTabs = true;\n      }\n    }\n\n    if (vorpalMatch) {\n      input.context = vorpalMatch;\n      evaluateTabs(input);\n      end(assembleInput(input));\n      return;\n    }\n\n    input = getMatchObject.call(this, input, commands);\n    if (input.match) {\n      input = parseMatchSection.call(this, input);\n      getMatchData.call(self, input, function (data) {\n        var dataMatch = getMatch(input.context, data);\n        if (dataMatch) {\n          input.context = dataMatch;\n          evaluateTabs(input);\n          end(assembleInput(input));\n          return;\n        }\n        end(filterData(input.context, data));\n      });\n      return;\n    }\n    end(filterData(input.context, commands));\n  },\n\n  /**\n   * Independent / stateless auto-complete function.\n   * Parses an array of strings for the best match.\n   *\n   * @param {String} str\n   * @param {Array} arr\n   * @return {String}\n   * @api private\n   */\n\n  match: function match(str, arr, options) {\n    arr = arr || [];\n    options = options || {};\n    arr.sort();\n    var arrX = _.clone(arr);\n    var strX = String(str);\n\n    var prefix = '';\n\n    if (options.ignoreSlashes !== true) {\n      var parts = strX.split('/');\n      strX = parts.pop();\n      prefix = parts.join('/');\n      prefix = parts.length > 0 ? prefix + '/' : prefix;\n    }\n\n    var matches = [];\n    for (var i = 0; i < arrX.length; i++) {\n      if (strip(arrX[i]).slice(0, strX.length) === strX) {\n        matches.push(arrX[i]);\n      }\n    }\n    if (matches.length === 1) {\n      // If we have a slash, don't add a space after match.\n      var space = String(strip(matches[0])).slice(strip(matches[0]).length - 1) === '/' ? '' : ' ';\n      return prefix + matches[0] + space;\n    } else if (matches.length === 0) {\n      return undefined;\n    } else if (strX.length === 0) {\n      return matches;\n    }\n\n    var longestMatchLength = matches.reduce(function (previous, current) {\n      for (var i = 0; i < current.length; i++) {\n        if (previous[i] && current[i] !== previous[i]) {\n          return current.substr(0, i);\n        }\n      }\n      return previous;\n    }).length;\n\n    // couldn't resolve any further, return all matches\n    if (longestMatchLength === strX.length) {\n      return matches;\n    }\n\n    // return the longest matching portion along with the prefix\n    return prefix + matches[0].substr(0, longestMatchLength);\n  }\n};\n\n/**\n * Tracks how many times tab was pressed\n * based on whether the UI changed.\n *\n * @param {String} str\n * @return {String} result\n * @api private\n */\n\nfunction handleTabCounts(str, freezeTabs) {\n  var result;\n  if (_.isArray(str)) {\n    this._tabCtr += 1;\n    if (this._tabCtr > 1) {\n      result = str.length === 0 ? undefined : str;\n    }\n  } else {\n    this._tabCtr = freezeTabs === true ? this._tabCtr + 1 : 0;\n    result = str;\n  }\n  return result;\n}\n\n/**\n * Looks for a potential exact match\n * based on given data.\n *\n * @param {String} ctx\n * @param {Array} data\n * @return {String}\n * @api private\n */\n\nfunction getMatch(ctx, data, options) {\n  // Look for a command match, eliminating and then\n  // re-introducing leading spaces.\n  var len = ctx.length;\n  var trimmed = ctx.replace(/^\\s+/g, '');\n  var match = autocomplete.match(trimmed, data.slice(), options);\n  if (_.isArray(match)) {\n    return match;\n  }\n  var prefix = new Array(len - trimmed.length + 1).join(' ');\n  // If we get an autocomplete match on a command, finish it.\n  if (match) {\n    // Put the leading spaces back in.\n    match = prefix + match;\n    return match;\n  }\n  return undefined;\n}\n\n/**\n * Takes the input object and assembles\n * the final result to display on the screen.\n *\n * @param {Object} input\n * @return {String}\n * @api private\n */\n\nfunction assembleInput(input) {\n  if (_.isArray(input.context)) {\n    return input.context;\n  }\n  var result = (input.prefix || '') + (input.context || '') + (input.suffix || '');\n  return strip(result);\n}\n\n/**\n * Reduces an array of possible\n * matches to list based on a given\n * string.\n *\n * @param {String} str\n * @param {Array} data\n * @return {Array}\n * @api private\n */\n\nfunction filterData(str, data) {\n  data = data || [];\n  var ctx = String(str || '').trim();\n  var slashParts = ctx.split('/');\n  ctx = slashParts.pop();\n  var wordParts = String(ctx).trim().split(' ');\n  var res = data.filter(function (item) {\n    return strip(item).slice(0, ctx.length) === ctx;\n  });\n  res = res.map(function (item) {\n    var parts = String(item).trim().split(' ');\n    if (parts.length > 1) {\n      parts = parts.slice(wordParts.length);\n      return parts.join(' ');\n    }\n    return item;\n  });\n  return res;\n}\n\n/**\n * Takes the user's current prompt\n * string and breaks it into its\n * integral parts for analysis and\n * modification.\n *\n * @param {String} str\n * @param {Integer} idx\n * @return {Object}\n * @api private\n */\n\nfunction parseInput(str, idx) {\n  var raw = String(str || '');\n  var sliced = raw.slice(0, idx);\n  var sections = sliced.split('|');\n  var prefix = sections.slice(0, sections.length - 1) || [];\n  prefix.push('');\n  prefix = prefix.join('|');\n  var suffix = getSuffix(raw.slice(idx));\n  var context = sections[sections.length - 1];\n  return {\n    raw: raw,\n    prefix: prefix,\n    suffix: suffix,\n    context: context\n  };\n}\n\n/**\n * Takes the context after a\n * matched command and figures\n * out the applicable context,\n * including assigning its role\n * such as being an option\n * parameter, etc.\n *\n * @param {Object} input\n * @return {Object}\n * @api private\n */\n\nfunction parseMatchSection(input) {\n  var parts = (input.context || '').split(' ');\n  var last = parts.pop();\n  var beforeLast = strip(parts[parts.length - 1] || '').trim();\n  if (beforeLast.slice(0, 1) === '-') {\n    input.option = beforeLast;\n  }\n  input.context = last;\n  input.prefix = (input.prefix || '') + parts.join(' ') + ' ';\n  return input;\n}\n\n/**\n * Returns a cleaned up version of the\n * remaining text to the right of the cursor.\n *\n * @param {String} suffix\n * @return {String}\n * @api private\n */\n\nfunction getSuffix(suffix) {\n  suffix = suffix.slice(0, 1) === ' ' ? suffix : suffix.replace(/.+?(?=\\s)/, '');\n  suffix = suffix.slice(1, suffix.length);\n  return suffix;\n}\n\n/**\n * Compile all available commands and aliases\n * in alphabetical order.\n *\n * @param {Array} cmds\n * @return {Array}\n * @api private\n */\n\nfunction getCommandNames(cmds) {\n  var commands = _.map(cmds, '_name');\n  commands = commands.concat.apply(commands, _.map(cmds, '_aliases'));\n  commands.sort();\n  return commands;\n}\n\n/**\n * When we know that we've\n * exceeded a known command, grab\n * on to that command and return it,\n * fixing the overall input context\n * at the same time.\n *\n * @param {Object} input\n * @param {Array} commands\n * @return {Object}\n * @api private\n */\n\nfunction getMatchObject(input, commands) {\n  var len = input.context.length;\n  var trimmed = String(input.context).replace(/^\\s+/g, '');\n  var prefix = new Array(len - trimmed.length + 1).join(' ');\n  var match;\n  var suffix;\n  commands.forEach(function (cmd) {\n    var nextChar = trimmed.substr(cmd.length, 1);\n    if (trimmed.substr(0, cmd.length) === cmd && String(cmd).trim() !== '' && nextChar === ' ') {\n      match = cmd;\n      suffix = trimmed.substr(cmd.length);\n      prefix += trimmed.substr(0, cmd.length);\n    }\n  });\n\n  var matchObject = match ? _.find(this.parent.commands, { _name: String(match).trim() }) : undefined;\n\n  if (!matchObject) {\n    this.parent.commands.forEach(function (cmd) {\n      if ((cmd._aliases || []).indexOf(String(match).trim()) > -1) {\n        matchObject = cmd;\n      }\n      return;\n    });\n  }\n\n  if (!matchObject) {\n    matchObject = _.find(this.parent.commands, { _catch: true });\n    if (matchObject) {\n      suffix = input.context;\n    }\n  }\n\n  if (!matchObject) {\n    prefix = input.context;\n    suffix = '';\n  }\n\n  if (matchObject) {\n    input.match = matchObject;\n    input.prefix += prefix;\n    input.context = suffix;\n  }\n  return input;\n}\n\n/**\n * Takes a known matched command, and reads\n * the applicable data by calling its autocompletion\n * instructions, whether it is the command's\n * autocompletion or one of its options.\n *\n * @param {Object} input\n * @param {Function} cb\n * @return {Array}\n * @api private\n */\n\nfunction getMatchData(input, cb) {\n  var string = input.context;\n  var cmd = input.match;\n  var midOption = String(string).trim().slice(0, 1) === '-';\n  var afterOption = input.option !== undefined;\n  if (midOption === true) {\n    var results = [];\n    for (var i = 0; i < cmd.options.length; ++i) {\n      var long = cmd.options[i].long;\n      var short = cmd.options[i].short;\n      if (!long && short) {\n        results.push(short);\n      } else if (long) {\n        results.push(long);\n      }\n    }\n    cb(results);\n    return;\n  }\n\n  function handleDataFormat(str, config, callback) {\n    var data = [];\n    if (_.isArray(config)) {\n      data = config;\n    } else if (_.isFunction(config)) {\n      var cbk = config.length < 2 ? function () {} : function (res) {\n        callback(res || []);\n      };\n      var res = config(str, cbk);\n      if (res && _.isFunction(res.then)) {\n        res.then(function (resp) {\n          callback(resp);\n        }).catch(function (err) {\n          callback(err);\n        });\n      } else if (config.length < 2) {\n        callback(res);\n      }\n      return;\n    }\n    callback(data);\n    return;\n  }\n\n  if (afterOption === true) {\n    var opt = strip(input.option).trim();\n    var shortMatch = _.find(cmd.options, { short: opt });\n    var longMatch = _.find(cmd.options, { long: opt });\n    var match = longMatch || shortMatch;\n    if (match) {\n      var config = match.autocomplete;\n      handleDataFormat(string, config, cb);\n      return;\n    }\n  }\n\n  var conf = cmd._autocomplete;\n  conf = conf && conf.data ? conf.data : conf;\n  handleDataFormat(string, conf, cb);\n  return;\n}\n\nmodule.exports = autocomplete;","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/intercept.js":"'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar _ = require('lodash');\n\n/**\n * Intercepts stdout, passes thru callback\n * also pass console.error thru stdout so it goes to callback too\n * (stdout.write and stderr.write are both refs to the same stream.write function)\n * returns an unhook() function, call when done intercepting\n *\n * @param {Function} callback\n * @return {Function}\n */\n\nmodule.exports = function (callback) {\n  var oldStdoutWrite = process.stdout.write;\n  var oldConsoleError = console.error;\n  process.stdout.write = function (write) {\n    return function (string) {\n      var args = _.toArray(arguments);\n      args[0] = interceptor(string);\n      write.apply(process.stdout, args);\n    };\n  }(process.stdout.write);\n\n  console.error = function () {\n    return function () {\n      var args = _.toArray(arguments);\n      args.unshift('\\x1b[31m[ERROR]\\x1b[0m');\n      console.log.apply(console.log, args);\n    };\n  }(console.error);\n\n  function interceptor(string) {\n    // only intercept the string\n    var result = callback(string);\n    if (typeof result === 'string') {\n      string = result.replace(/\\n$/, '') + (result && /\\n$/.test(string) ? '\\n' : '');\n    }\n    return string;\n  }\n  // puts back to original\n  return function unhook() {\n    process.stdout.write = oldStdoutWrite;\n    console.error = oldConsoleError;\n  };\n};","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/vorpal-commons.js":"'use strict';\n\n/**\n * Function library for Vorpal's out-of-the-box\n * API commands. Imported into a Vorpal server\n * through vorpal.use(module).\n */\n\n/**\n * Module dependencies.\n */\n\nvar _ = require('lodash');\n\nmodule.exports = function (vorpal) {\n  /**\n   * Help for a particular command.\n   */\n\n  vorpal.command('help [command...]').description('Provides help for a given command.').action(function (args, cb) {\n    var self = this;\n    if (args.command) {\n      args.command = args.command.join(' ');\n      var name = _.find(this.parent.commands, { _name: String(args.command).toLowerCase().trim() });\n      if (name && !name._hidden) {\n        if (_.isFunction(name._help)) {\n          name._help(args.command, function (str) {\n            self.log(str);\n            cb();\n          });\n          return;\n        }\n        this.log(name.helpInformation());\n      } else {\n        this.log(this.parent._commandHelp(args.command));\n      }\n    } else {\n      this.log(this.parent._commandHelp(args.command));\n    }\n    cb();\n  });\n\n  /**\n   * Exits Vorpal.\n   */\n\n  vorpal.command('exit').alias('quit').description('Exits application.').action(function (args) {\n    args.options = args.options || {};\n    args.options.sessionId = this.session.id;\n    this.parent.exit(args.options);\n  });\n};","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/history.js":"'use strict';\n\nvar _ = require('lodash');\nvar LocalStorage = require('node-localstorage').LocalStorage;\nvar path = require('path');\nvar os = require('os');\n\n// Number of command histories kept in persistent storage\nvar HISTORY_SIZE = 500;\n\nvar temp = path.normalize(path.join(os.tmpdir(), '/.local_storage'));\nvar DEFAULT_STORAGE_PATH = temp;\n\nvar History = function History() {\n  this._storageKey = undefined;\n\n  // Prompt Command History\n  // Histctr moves based on number of times 'up' (+= ctr)\n  //  or 'down' (-= ctr) was pressed in traversing\n  // command history.\n  this._hist = [];\n  this._histCtr = 0;\n\n  // When in a 'mode', we reset the\n  // history and store it in a cache until\n  // exiting the 'mode', at which point we\n  // resume the original history.\n  this._histCache = [];\n  this._histCtrCache = 0;\n};\n\n/**\n * Initialize the history with local storage data\n * Called from setId when history id is set\n */\n\nHistory.prototype._init = function () {\n  if (!this._storageKey) {\n    return;\n  }\n\n  // Load history from local storage\n  var persistedHistory = JSON.parse(this._localStorage.getItem(this._storageKey));\n  if (_.isArray(persistedHistory)) {\n    Array.prototype.push.apply(this._hist, persistedHistory);\n  }\n};\n\n/**\n * Set id for this history instance.\n * Calls init internally to initialize\n * the history with the id.\n */\n\nHistory.prototype.setId = function (id) {\n  // Initialize a localStorage instance with default\n  // path if it is not initialized\n  if (!this._localStorage) {\n    this._localStorage = new LocalStorage(DEFAULT_STORAGE_PATH);\n  }\n  this._storageKey = 'cmd_history_' + id;\n  this._init();\n};\n\n/**\n * Initialize a local storage instance with\n * the path if not already initialized.\n *\n * @param path\n */\n\nHistory.prototype.setStoragePath = function (path) {\n  if (!this._localStorage) {\n    this._localStorage = new LocalStorage(path);\n  }\n};\n\n/**\n * Get previous history. Called when up is pressed.\n *\n * @return {String}\n */\n\nHistory.prototype.getPreviousHistory = function () {\n  this._histCtr++;\n  this._histCtr = this._histCtr > this._hist.length ? this._hist.length : this._histCtr;\n  return this._hist[this._hist.length - this._histCtr];\n};\n\n/**\n * Get next history. Called when down is pressed.\n *\n * @return {String}\n */\n\nHistory.prototype.getNextHistory = function () {\n  this._histCtr--;\n\n  // Return empty prompt if the we dont have any history to show\n  if (this._histCtr < 1) {\n    this._histCtr = 0;\n    return '';\n  }\n\n  return this._hist[this._hist.length - this._histCtr];\n};\n\n/**\n * Peek into history, without changing state\n *\n * @return {String}\n */\n\nHistory.prototype.peek = function (depth) {\n  depth = depth || 0;\n  return this._hist[this._hist.length - 1 - depth];\n};\n\n/**\n * A new command was submitted. Called when enter is pressed and the prompt is not empty.\n *\n * @param cmd\n */\n\nHistory.prototype.newCommand = function (cmd) {\n  // Always reset history when new command is executed.\n  this._histCtr = 0;\n\n  // Don't store command in history if it's a duplicate.\n  if (this._hist[this._hist.length - 1] === cmd) {\n    return;\n  }\n\n  // Push into history.\n  this._hist.push(cmd);\n\n  // Only persist history when not in mode\n  if (this._storageKey && !this._inMode) {\n    var persistedHistory = this._hist;\n    var historyLen = this._hist.length;\n    if (historyLen > HISTORY_SIZE) {\n      persistedHistory = this._hist.slice(historyLen - HISTORY_SIZE - 1, historyLen - 1);\n    }\n\n    // Add to local storage\n    this._localStorage.setItem(this._storageKey, JSON.stringify(persistedHistory));\n  }\n};\n\n/**\n * Called when entering a mode\n */\n\nHistory.prototype.enterMode = function () {\n  // Reassign the command history to a\n  // cache, replacing it with a blank\n  // history for the mode.\n  this._histCache = _.clone(this._hist);\n  this._histCtrCache = parseFloat(this._histCtr);\n  this._hist = [];\n  this._histCtr = 0;\n  this._inMode = true;\n};\n\n/**\n * Called when exiting a mode\n */\n\nHistory.prototype.exitMode = function () {\n  this._hist = this._histCache;\n  this._histCtr = this._histCtrCache;\n  this._histCache = [];\n  this._histCtrCache = 0;\n  this._inMode = false;\n};\n\n/**\n * Clears the command history\n * (Currently only used in unit test)\n */\n\nHistory.prototype.clear = function () {\n  if (this._storageKey) {\n    this._localStorage.removeItem(this._storageKey);\n  }\n};\n\nmodule.exports = History;","/home/travis/build/npmtest/node-npmtest-vorpal/node_modules/vorpal/dist/local-storage.js":"'use strict';\n\nvar LocalStorageO = require('node-localstorage').LocalStorage;\nvar path = require('path');\nvar os = require('os');\nvar temp = path.normalize(path.join(os.tmpdir(), '/.local_storage_'));\nvar DEFAULT_STORAGE_PATH = temp;\n\nvar LocalStorage = {\n  setId: function setId(id) {\n    if (id === undefined) {\n      throw new Error('vorpal.localStorage() requires a unique key to be passed in.');\n    }\n    if (!this._localStorage) {\n      this._localStorage = new LocalStorageO(DEFAULT_STORAGE_PATH + id);\n    }\n  },\n  validate: function validate() {\n    if (this._localStorage === undefined) {\n      throw new Error('Vorpal.localStorage() was not initialized before writing data.');\n    }\n  },\n  getItem: function getItem(key, value) {\n    this.validate();\n    return this._localStorage.getItem(key, value);\n  },\n  setItem: function setItem(key, value) {\n    this.validate();\n    return this._localStorage.setItem(key, value);\n  },\n  removeItem: function removeItem(key) {\n    this.validate();\n    return this._localStorage.removeItem(key);\n  }\n};\n\nmodule.exports = LocalStorage;"}